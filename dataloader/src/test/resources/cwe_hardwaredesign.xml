<?xml version="1.0" encoding="UTF-8"?>
<Weakness_Catalog xmlns="http://cwe.mitre.org/cwe-6" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" Name="VIEW LIST: CWE-1194: Hardware Design" Version="4.0" Date="2020-02-24" xsi:schemaLocation="http://cwe.mitre.org/cwe-6 http://cwe.mitre.org/data/xsd/cwe_schema_v6.2.xsd">
   <Weaknesses>
      <Weakness ID="1053" Name="Missing Documentation for Design" Abstraction="Base" Structure="Simple" Status="Incomplete">
         <Description>The product does not have documentation that represents how it is designed.</Description>
         <Extended_Description><xhtml:p>This issue can make it more difficult to understand and maintain the product. It can make it more difficult and time-consuming to detect and/or fix vulnerabilities.</xhtml:p></Extended_Description>
         <Related_Weaknesses>
           <Related_Weakness Nature="ChildOf" CWE_ID="1059" View_ID="1000" Ordinal="Primary"/>
         </Related_Weaknesses>
         <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Indirect</Ordinality>
            </Weakness_Ordinality>
         </Weakness_Ordinalities>
         <References>
            <Reference External_Reference_ID="REF-963"/>
         </References>
         <Content_History>
            <Submission>
               <Submission_Name>CWE Content Team</Submission_Name>
               <Submission_Organization>MITRE</Submission_Organization>
               <Submission_Date>2018-07-02</Submission_Date>
               <Submission_Comment>Entry derived from Common Quality Enumeration (CQE) Draft 0.9.</Submission_Comment>
            </Submission>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-02-24</Modification_Date>
					<Modification_Comment>updated Description, Relationships</Modification_Comment>
				</Modification>
         </Content_History>
      </Weakness>
      <Weakness ID="1189" Name="Improper Isolation of Shared Resources on System-on-Chip (SoC)" Abstraction="Base" Structure="Simple" Status="Draft">
         <Description>The product does not properly isolate shared resources between trusted and untrusted agents.</Description>
         <Extended_Description>
            <xhtml:p>A System-On-Chip (SoC) has a lot of functionality, but may have a limited number of pins or pads. A pin can only perform one function at a time. However, it can be configured to perform multiple different functions. This technique is called pin multiplexing. Similarly, several resources on the chip may be shared to multiplex and support different features or functions. When such resources are shared between trusted and untrusted agents, untrusted agents may be able to access the assets intended to be accessed only by the trusted agents.</xhtml:p>
         </Extended_Description>
         <Related_Weaknesses>
            <Related_Weakness Nature="ChildOf" CWE_ID="668" View_ID="1000" Ordinal="Primary"/>
         </Related_Weaknesses>
         <Applicable_Platforms>
            <Language Class="Language-Independent" Prevalence="Undetermined"/>
            <Technology Class="System on Chip" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
            </Introduction>
            <Introduction>
               <Phase>Implementation</Phase>
            </Introduction>
         </Modes_Of_Introduction>
         <Common_Consequences>
            <Consequence>
               <Scope>Access Control</Scope>
               <Impact>Bypass Protection Mechanism</Impact>
               <Note>If shared resources are being used by a trusted user, it may be possible for untrusted agents to modify the functionality of the shared resource for the trusted user.</Note>
            </Consequence>
            <Consequence>
               <Scope>Integrity</Scope>
               <Impact>Quality Degradation</Impact>
               <Note>The functionality of the shared resource may be intentionally degraded.</Note>
            </Consequence>
         </Common_Consequences>
         <Detection_Methods>
            <Detection_Method>
               <Method>Automated Static Analysis - Binary or Bytecode</Method>
               <Description>
                  <xhtml:p>Kernel integrity verification can help identify when shared resource configuration settings have been modified.</xhtml:p>
               </Description>
               <Effectiveness>High</Effectiveness>
            </Detection_Method>
         </Detection_Methods>
         <Potential_Mitigations>
            <Mitigation>
               <Phase>Architecture and Design</Phase>
               <Strategy>Separation of Privilege</Strategy>
               <Description>
                 <xhtml:p>When sharing resources, avoid mixing agents of varying trust levels.</xhtml:p>
                 <xhtml:p>Group untrusted agents together to access when sharing a resource. Similarly, group trusted agents (at same trust level).</xhtml:p>
               </Description>
            </Mitigation>
         </Potential_Mitigations>
         <References>
            <Reference External_Reference_ID="REF-1036"/>
         </References>
         <Content_History>
            <Submission>
               <Submission_Organization>Intel Corporation</Submission_Organization>
               <Submission_Date>2019-10-15</Submission_Date>
            </Submission>
         </Content_History>
      </Weakness>
      <Weakness ID="1190" Name="DMA Device Enabled Too Early in Boot Phase" Abstraction="Base" Structure="Simple" Status="Draft">
         <Description>The product enables a Direct Memory Access (DMA) capable device before the security configuration settings are established, which allows an attacker to extract data from or gain privileges on the product.</Description>
         <Extended_Description>
            <xhtml:p>DMA is included in a number of devices because it allows
              data transfer between the computer and the connected device, using
              direct hardware access to read or write directly to main memory
              without any OS interaction. An attacker could exploit this to
              access secrets. Several virtualization-based mitigations have been introduced to thwart DMA attacks. These are usually
              configured/setup during boot time. However, certain IPs that are
              powered up before boot is complete (known as early boot IPs) may
              be DMA capable. Such IPs, if not trusted, could launch DMA
              attacks and gain access to assets that should otherwise be
              protected.</xhtml:p>
         </Extended_Description>
         <Related_Weaknesses>
            <Related_Weakness Nature="ChildOf" CWE_ID="696" View_ID="1000" Ordinal="Primary"/>
         </Related_Weaknesses>
         <Applicable_Platforms>
            <Language Class="Language-Independent" Prevalence="Undetermined"/>
            <Technology Class="System on Chip" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
            </Introduction>
         </Modes_Of_Introduction>
		 <Common_Consequences>
            <Consequence>
               <Scope>Access Control</Scope>
               <Impact>Bypass Protection Mechanism</Impact>
			   <Impact>Modify Memory</Impact>
			   <Likelihood>High</Likelihood>
               <Note>DMA devices have direct write access to main memory and
                 due to time of attack will be able to bypass OS or Bootloader
                 access control.</Note>
            </Consequence>
         </Common_Consequences>
         <Potential_Mitigations>
            <Mitigation>
               <Phase>Architecture and Design</Phase>
               <Description>Utilize an IOMMU to orchestrate IO access from
                 the start of the boot process.</Description>
            </Mitigation>
          </Potential_Mitigations>
         <References>
            <Reference External_Reference_ID="REF-1038"/>
            <Reference External_Reference_ID="REF-1039"/>
            <Reference External_Reference_ID="REF-1040"/>
            <Reference External_Reference_ID="REF-1041"/>
            <Reference External_Reference_ID="REF-1042"/>
            <Reference External_Reference_ID="REF-1044"/>
            <Reference External_Reference_ID="REF-1046"/>
         </References>
         <Content_History>
            <Submission>
               <Submission_Organization>Intel Corporation</Submission_Organization>
               <Submission_Date>2019-10-15</Submission_Date>
            </Submission>
         </Content_History>
      </Weakness>
      <Weakness ID="1191" Name="Exposed Chip Debug Interface With Insufficient Access Control" Abstraction="Base" Structure="Simple" Status="Draft">
         <Description>The chip does not implement or does not correctly
           enforce access control on the debug interface, thus allowing an
           attacker to exercise the debug interface to access a portion of
           the chip internal registers that typically would not be
           exposed.</Description>
         <Extended_Description>
            <xhtml:p>Integrated circuits can expose the chip internals through a
              scan chain interconnected through internal registers etc., through
              scan flip-flops. A Joint Test Action Group (JTAG) compatible test access port usually
              provides access to this scan chain for debugging the chip. Since
              almost every asset in the chip can be accessed over this debug
              interface, chip manufacturers typically insert some form of
              password-based or challenge-response based access control
              mechanisms to prevent misuse. This mechanism is implemented in
              addition to on-chip protections that are already present. If this
              debug access control is not implemented or the access control
              check is not implemented properly, or if the hardware does not
              clear secret keys, etc., when debug more is entered, an attacker
              may be able to bypass on-chip access control mechanisms through
              debug features/interfaces.</xhtml:p>
         </Extended_Description>
         <Related_Weaknesses>
            <Related_Weakness Nature="ChildOf" CWE_ID="284" View_ID="1000" Ordinal="Primary"/>
         </Related_Weaknesses>
         <Applicable_Platforms>
            <Language Class="Language-Independent" Prevalence="Undetermined"/>
            <Technology Class="System on Chip" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
            </Introduction>
            <Introduction>
               <Phase>Implementation</Phase>
            </Introduction>
         </Modes_Of_Introduction>
         <Common_Consequences>
            <Consequence>
               <Scope>Access Control</Scope>
               <Impact>Bypass Protection Mechanism</Impact>
			   <Likelihood>High</Likelihood>
            </Consequence>
         </Common_Consequences>
         <Potential_Mitigations>
            <Mitigation>
                <Phase>Architecture and Design</Phase>
                <Strategy>Separation of Privilege</Strategy>
                <Description>
                  <xhtml:p>
                    Implement an access control mechanism to exercise the debug
                    interface in order to control and observe security-sensitive
                    chip internals. 
                  </xhtml:p>
                  <xhtml:p>
                    Password checking logic should be resistant to timing
                    attacks. Security-sensitive data stored in registers, such
                    as keys, etc. should be cleared when entering debug mode.
                  </xhtml:p>
                </Description>
            </Mitigation>
         </Potential_Mitigations>
         <Observed_Examples>
           <Observed_Example>
             <Reference>CVE-2019-18827</Reference>
             <Description>chain: JTAG interface is not disabled (CWE-1191) during ROM code execution, introducing a race condition (CWE-362) to extract encryption keys</Description>
             <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18827</Link>
           </Observed_Example>
         </Observed_Examples>
         <References>
            <Reference External_Reference_ID="REF-1037"/>
            <Reference External_Reference_ID="REF-1043"/>
         </References>
         <Content_History>
            <Submission>
               <Submission_Organization>Intel Corporation</Submission_Organization>
               <Submission_Date>2019-10-15</Submission_Date>
            </Submission>
         </Content_History>
      </Weakness>
      <Weakness ID="1192" Name="System-on-Chip (SoC) Using Components without Unique, Immutable Identifiers" Abstraction="Base" Structure="Simple" Status="Draft">
         <Description>The System-on-Chip (SoC) does not have unique, immutable identifiers for each of its components.</Description>
         <Extended_Description>
	   <xhtml:p>A System-on-Chip (SoC) comprises several components (IP) with varied
           trust requirements. It is required that each IP is identified
           uniquely and should distinguish itself from other entities in
           the SoC without any ambiguity. The unique secured identity is
           required for various purposes. Most of the time the identity is used
           to route a transaction or perform certain actions (i.e.
           resetting, retrieving a sensitive information, and acting upon or on
           behalf of), etc.</xhtml:p>
           <xhtml:p>There are several variants of this weakness:</xhtml:p>
            <xhtml:ul>
	      <xhtml:li>A "missing" identifier is when the SoC does not define
	      any mechanism to uniquely identify the IP.</xhtml:li>
	      <xhtml:li>An "insufficient" identifier might provide
	      some defenses - for example, against the most common
	      attacks - but it does not protect against everything
	      that is intended.</xhtml:li>
	      <xhtml:li>A "misconfigured" mechanism occurs when a mechanism
              is available but not implemented correctly.</xhtml:li>
	      <xhtml:li>An "ignored" identifier occurs when the SoC/IP has not applied
	      any policies or does not act upon the identifier securely.</xhtml:li>
            </xhtml:ul>
         </Extended_Description>
          <Related_Weaknesses>
            <Related_Weakness Nature="ChildOf" CWE_ID="657" View_ID="1000" Ordinal="Primary"/>
         </Related_Weaknesses>
        <Applicable_Platforms>
            <Language Class="Language-Independent" Prevalence="Undetermined"/>
            <Technology Class="System on Chip" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
            </Introduction>
            <Introduction>
               <Phase>Implementation</Phase>
            </Introduction>
            <Introduction>
               <Phase>Operation</Phase>
            </Introduction>
         </Modes_Of_Introduction>
         <Common_Consequences>
            <Consequence>
               <Scope>Access Control</Scope>
               <Impact>Bypass Protection Mechanism</Impact>
			   <Likelihood>High</Likelihood>
            </Consequence>
         </Common_Consequences>
         <Potential_Mitigations>
            <Mitigation>
                <Phase>Architecture and Design</Phase>
                <Strategy>Separation of Privilege</Strategy>
                <Description>
                  <xhtml:p>
                    Every identity generated in the SoC should be unique and
                    immutable in hardware. The actions that an IP is trusted or
                    not trusted should be clearly defined, implemented,
                    configured, and tested. If the definition is implemented via a
                    policy, then the policy should be immutable or protected with
                    clear authentication and authorization.
                  </xhtml:p>
                </Description>
            </Mitigation>
         </Potential_Mitigations>
         <Content_History>
            <Submission>
               <Submission_Organization>Intel Corporation</Submission_Organization>
               <Submission_Date>2019-10-15</Submission_Date>
            </Submission>
         </Content_History>
      </Weakness>
      <Weakness ID="1193" Name="Power-On of Untrusted Execution Core Before Enabling Fabric Access Control" Abstraction="Base" Structure="Simple" Status="Draft">
        <Description>The product enables components that contain untrusted firmware before memory and fabric access controls have been enabled.</Description>
	<Extended_Description>
	  <xhtml:p>
	   After initial reset, System-on-Chip (SoC) fabric access controls and other
           security features need to be programmed by trusted firmware as part
           of the boot sequence. If untrusted IPs or peripheral microcontrollers
	   are enabled first, then the untrusted component can master
           transactions on the hardware bus and target memory or other assets to
           compromise the SoC boot firmware.</xhtml:p></Extended_Description>
         <Related_Weaknesses>
            <Related_Weakness Nature="ChildOf" CWE_ID="696" View_ID="1000" Ordinal="Primary"/>
         </Related_Weaknesses>
		 <Common_Consequences>
            <Consequence>
               <Scope>Access Control</Scope>
               <Impact>Bypass Protection Mechanism</Impact>
			   <Likelihood>High</Likelihood>
               <Note>An untrusted component can master transactions on the HW bus and target memory or other assets to compromise the SoC boot firmware.</Note>
            </Consequence>
         </Common_Consequences>
         <Potential_Mitigations>
            <Mitigation>
                <Phase>Architecture and Design</Phase>
                <Description>
                  <xhtml:p>The boot sequence should enable fabric access controls and memory protections before enabling third-party hardware IPs and peripheral microcontrollers that use untrusted firmware.</xhtml:p>
                </Description>
            </Mitigation>
         </Potential_Mitigations>
         <References>
            <Reference External_Reference_ID="REF-1042"/>
         </References>
         <Content_History>
            <Submission>
               <Submission_Organization>Intel Corporation</Submission_Organization>
               <Submission_Date>2019-10-15</Submission_Date>
            </Submission>
         </Content_History>
      </Weakness>
      <Weakness ID="1209" Name="Failure to Disable Reserved Bits" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The reserved bits in a hardware design are not disabled prior to production. Typically, reserved bits are used for future capabilities and should not support any functional logic in the design.   However, designers might covertly use these bits to debug or further develop new capabilities in production hardware. Adversaries with access to these bits will write to them in hopes of compromising hardware state.</Description>
            <Extended_Description>
                <xhtml:p>Reserved bits are labeled as such so they can be allocated for a later purpose. They are not to do anything in the current design.  However, designers might want to use these bits to debug or control/configure a future capability to help minimize time to market (TTM). If the logic being controlled by these bits is still enabled in production, an adversary could use the logic to induce unwanted/unsupported behavior in the hardware.</xhtml:p>
            </Extended_Description>
         <Related_Weaknesses>
            <Related_Weakness Nature="ChildOf" CWE_ID="710" View_ID="1000" Ordinal="Primary"/>
         </Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                    <Note>The Designer and Implementer have to make a conscious choice to do this</Note>
                </Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                    <Note>The Designer and Implementer have to make a conscious choice to do this</Note>
                </Introduction>
                <Introduction>
                    <Phase>Documentation</Phase>
                    <Note>If documentation labels anything "for future use", "reserved", or the like, such labeling could indicate to an attacker a potential attack point</Note>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Confidentiality</Scope>
                    <Scope>Integrity</Scope>
                    <Scope>Availability</Scope>
                    <Scope>Access Control</Scope>
                    <Scope>Accountability</Scope>
                    <Scope>Authentication</Scope>
                    <Scope>Authorization</Scope>
                    <Scope>Non-Repudiation</Scope>
                    <Impact>Varies by Context</Impact>
                    <Note>This type of weakness all depends on the capabilities of the logic being controlled or configured by the reserved bits</Note>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Description>
                        <xhtml:p>Include a feature disable</xhtml:p>                     
                    </Description>
                </Mitigation>
                <Mitigation>
                    <Phase>Integration</Phase>
                    <Description>
                    	<xhtml:p>Any writes to these reserve bits are blocked (e.g., ignored, access-protected, etc.), or an exception can be asserted.</xhtml:p>
                    </Description>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>An adversary may perform writes to reserve space in hopes to change the behavior of the hardware.</Intro_Text>
                    <Example_Code Nature="bad" Language="Other">
                        <xhtml:div>// Assume an IP has address space 0x0-0x0F for its configuration registers, with the last one labeled reserved (i.e. 0x0F).  Therefore inside the Finite State Machine (FSM), the code is as follows:
                        <xhtml:br/>
                        <xhtml:br/>reg gpio_out = 0;  //gpio should remain low for normal operation
                        <xhtml:br/>
                        <xhtml:br/>case (register_address)
                        <xhtml:br/>		4'b1111 : //0x0F
                        <xhtml:br/>			begin
                        <xhtml:br/>				gpio_out = 1;  
                        <xhtml:br/>			end</xhtml:div>
                    </Example_Code>
                    <Body_Text>In the code above, the GPIO pin should remain low for normal operation.  However, it can be asserted by accessing the reserved address space (0x0F).  This may be a concern if the GPIO state is being used as an indicator of health (e.g. if asserted the hardware may respond by shutting down or resetting the system which may not be the correct action the system should perform).</Body_Text>
                	<Example_Code Nature="informative">
                  		<xhtml:div>reg gpio_out = 0;  //gpio should remain low for normal operation
                  		<xhtml:br/>case (register_address)
                  		<xhtml:br/>		//4'b1111 : //0x0F
                  		<xhtml:br/>		default: gpio_out = gpio_out;</xhtml:div>
               		</Example_Code>
            	</Demonstrative_Example>
            </Demonstrative_Examples>
            <Content_History>
                <Submission>
                    <Submission_Name>Brent Sherman</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-02-06</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1220" Name="Insufficient Granularity of Access Control" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The product implements access controls via a policy or other feature with the intention to disable or restrict accesses (reads and/or writes) to assets in a system from untrusted agents. However, implemented access controls lack required granularity, which renders the control policy too broad because it allows accesses from unauthorized agents to the security-sensitive assets.</Description>
            <Extended_Description>
                <xhtml:p>Integrated circuits and hardware engines can expose accesses to assets (device configuration, keys, etc.) to trusted firmware or a software module (commonly set by BIOS/bootloader). This access is typically access-controlled. Upon a power reset, the hardware or system usually starts with default values in registers, and the trusted firmware (Boot firmware) configures the necessary access-control protection.</xhtml:p>
                <xhtml:p>A common weakness that can exist in such protection schemes is that access controls or policies are not granular enough. This condition allows agents beyond trusted agents to access assets and could lead to a loss of functionality or the ability to set up the device securely. This further results in security risks from leaked, sensitive, key material to modification of device configuration.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="284" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Class="Technology-Independent" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                    <Note>Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.</Note>
                </Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                    <Note>Such issues could be introduced during hardware implementation and identified later during Testing or System Configuration phases.</Note>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Confidentiality</Scope>
                    <Scope>Integrity</Scope>
                    <Scope>Availability</Scope>
                    <Scope>Access Control</Scope>
                    <Impact>Modify Memory</Impact>
                    <Impact>Read Memory</Impact>
                    <Impact>Execute Unauthorized Code or Commands</Impact>
                    <Impact>Gain Privileges or Assume Identity</Impact>
                    <Impact>Bypass Protection Mechanism</Impact>
                    <Impact>Other</Impact>
                    <Likelihood>High</Likelihood>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Phase>Testing</Phase>
                    <Description>
                        <xhtml:ul>
                            <xhtml:li>Access-control-policy protections must be reviewed for design inconsistency and common weaknesses.</xhtml:li>
                            <xhtml:li>Access-control-policy definition and programming flow must be tested in pre-silicon, post-silicon testing.</xhtml:li>
                        </xhtml:ul>
                    </Description>
                    <Effectiveness>High</Effectiveness>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>
                        <xhtml:p>Consider a system with a register for storing AES key for encryption or decryption. The key is 128 bits, implemented as a set of four 32-bit registers. The key registers are assets and registers, AES_KEY_READ_POLICY and AES_KEY_WRITE_POLICY, and are defined to provide necessary access controls.</xhtml:p>
                        <xhtml:p>The read-policy register defines which agents can read the AES-key registers, and write-policy register defines which agents can program or write to those registers. Each register is a 32-bit register, and it can support access control for a maximum of 32 agents. The number of the bit when set (i.e., "1") allows respective action from an agent whose identity matches the number of the bit and, if "0" (i.e., Clear), disallows the respective action to that corresponding agent.</xhtml:p>
                    </Intro_Text>
                    <Example_Code Nature="bad" Language="Other">
                        <xhtml:table>
                            <xhtml:tr>
                                <xhtml:th>Register</xhtml:th>
                                <xhtml:th>Field description</xhtml:th>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>AES_ENC_DEC_KEY_0</xhtml:td>
                                <xhtml:td>AES key [0:31] for encryption or decryption<xhtml:br/>Default 0x00000000</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>AES_ENC_DEC_KEY_1</xhtml:td>
                                <xhtml:td>AES key [32:63] for encryption or decryption<xhtml:br/>Default 0x00000000</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>AES_ENC_DEC_KEY_2</xhtml:td>
                                <xhtml:td>AES key [64:95] for encryption or decryption<xhtml:br/>Default 0x00000000</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>AES_ENC_DEC_KEY_4</xhtml:td>
                                <xhtml:td>AES key [96:127] for encryption or decryption<xhtml:br/>Default 0x00000000</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>AES_KEY_READ_WRITE_POLICY</xhtml:td>
                                <xhtml:td>[31:0] Default 0x00000006 - meaning agent with identities "1" and "2" can both read from and write to key registers</xhtml:td>
                            </xhtml:tr>
                        </xhtml:table>
                    </Example_Code>
                    <Body_Text>In the above example, there is only one policy register that controls access to both read and write accesses to the AES-key registers, and thus the design is not granular enough to separate read and writes access for different agents. Here, agent with identities "1" and "2" can both read and write.</Body_Text>
                    <Body_Text>A good design should be granular enough to provide separate access controls to separate actions. Access control for reads should be separate from writes. Below is an example of such implementation where two policy registers are defined for each of these actions. The policy is defined such that: the AES-key registers can only be read or used by a crypto agent with identity "1" when bit #1 is set. The AES-key registers can only be programmed by a trusted firmware with identity "2" when bit #2 is set.</Body_Text>
                    <Example_Code Nature="mitigation">
                        <xhtml:table>
                            <xhtml:tr>
                                <xhtml:td>AES_KEY_READ_POLICY</xhtml:td>
                                <xhtml:td>[31:0] Default 0x00000002 - meaning only Crypto engine with identity "1" can read registers: AES_ENC_DEC_KEY_0, AES_ENC_DEC_KEY_1, AES_ENC_DEC_KEY_2, AES_ENC_DEC_KEY_3</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>AES_KEY_WRITE_POLICY</xhtml:td>
                                <xhtml:td>[31:0] Default 0x00000004 - meaning only trusted firmware with identity "2" can program registers: AES_ENC_DEC_KEY_0, AES_ENC_DEC_KEY_1, AES_ENC_DEC_KEY_2, AES_ENC_DEC_KEY_3</xhtml:td>
                            </xhtml:tr>
                        </xhtml:table>
                    </Example_Code>
                </Demonstrative_Example>
            </Demonstrative_Examples>
            <Content_History>
                <Submission>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-02-05</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1221" Name="Incorrect Register Defaults or Module Parameters" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>Hardware description language code incorrectly defines register defaults or hardware IP parameters to insecure values.</Description>
            <Extended_Description>
                <xhtml:p>Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to defined default values that are hard coded in the hardware description language (HDL) code of the hardware unit. Hardware descriptive languages also support definition of parameter variables, which can be defined in code during instantiation of the hardware IP module. Such parameters are generally used to configure a specific instance of a hardware IP in the design.</xhtml:p>
                <xhtml:p>The system security settings of a hardware design can be affected by incorrectly defined default values or IP parameters. The hardware IP would be in an insecure state at power reset, and this can be exposed or exploited by untrusted software running on the system. Both register defaults and parameters are hardcoded values, which cannot be changed using software or firmware patches but must be changed in hardware silicon. Thus, such security issues are considerably more difficult to address later in the lifecycle. Hardware designs can have a large number of such parameters and register defaults settings, and it is important to have design tool support to check these settings in an automated way and be able to identify which settings are security sensitive.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="665" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Name="Verilog" Prevalence="Undetermined"/>
                <Language Name="VHDL" Prevalence="Undetermined"/>
                <Technology Class="Technology-Independent" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                    <Note>Such issues could be introduced during implementation of hardware design, since IP parameters and defaults are defined in HDL code and identified later during Testing or System Configuration phases.</Note>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Confidentiality</Scope>
                    <Scope>Integrity</Scope>
                    <Scope>Availability</Scope>
                    <Scope>Access Control</Scope>
                    <Impact>Varies by Context</Impact>
                    <Note>Degradation of system functionality, or loss of access control enforcement</Note>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Description>During hardware design all the system parameters and register defaults must be reviewed to identify security sensitive settings</Description>
                </Mitigation>
                <Mitigation>
                    <Phase>Implementation</Phase>
                    <Description>The default values of these security sensitive settings need to be defined as part of the design review phase.</Description>
                </Mitigation>
                <Mitigation>
                    <Phase>Testing</Phase>
                    <Description>Testing phase should use automated tools to test that values are configured per design specifications.</Description>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>Consider example design module system verilog code shown below.register_example module is an example parameterized module that defines two parameters, REGISTER_WIDTH and REGISTER_DEFAULT. Register_example module defines a Secure_mode setting, which when set makes the register content read-only and not modifiable by software writes. register_top module instantiates two registers, Insecure_Device_ID_1 and Insecure_Device_ID_2. Generally, registers containing device identifier values are required to be read only to prevent any possibility of software modifying these values. </Intro_Text>
                    <Example_Code Nature="bad" Language="Verilog">
                        <xhtml:div>// Parameterized Register module example <xhtml:br/>// Secure_mode : REGISTER_DEFAULT[0] : When set to 1 register is read only and not writable// <xhtml:br/>/module register_example <xhtml:br/>s#( <xhtml:br/> parameter REGISTER_WIDTH = 8, // Parameter defines width of register, default 8 bits <xhtml:br/> parameter [REGISTER_WIDTH-1:0] REGISTER_DEFAULT = 2**REGISTER_WIDTH -2 // Default value of register computed from Width. Sets all bits to 1s except bit 0 (Secure _mode) <xhtml:br/>) <xhtml:br/>( <xhtml:br/>input [REGISTER_WIDTH-1:0] Data_in, <xhtml:br/>input Clk, <xhtml:br/>input resetn, <xhtml:br/>input write, <xhtml:br/>output reg [REGISTER_WIDTH-1:0] Data_out <xhtml:br/>); <xhtml:br/>
                            <xhtml:br/>reg Secure_mode; <xhtml:br/>
                            <xhtml:br/>always @(posedge Clk or negedge resetn) <xhtml:br/> if (~resetn) <xhtml:br/> begin <xhtml:br/> Data_out &lt;= REGISTER_DEFAULT; // Register content set to Default at reset <xhtml:br/> Secure_mode &lt;= REGISTER_DEFAULT[0]; // Register Secure_mode set at reset <xhtml:br/>end <xhtml:br/>else if (write &amp; ~Secure_mode) <xhtml:br/>begin <xhtml:br/> Data_out &lt;= Data_in; <xhtml:br/>end <xhtml:br/>endmodule <xhtml:br/>
                            <xhtml:br/>
                            <xhtml:br/>module register_top <xhtml:br/>( <xhtml:br/>input Clk, <xhtml:br/>input resetn, <xhtml:br/>input write, <xhtml:br/>input [31:0] Data_in, <xhtml:br/>output reg [31:0] Secure_reg, <xhtml:br/>output reg [31:0] Insecure_reg <xhtml:br/>); <xhtml:br/>
                            <xhtml:br/>register_example #( <xhtml:br/> .REGISTER_WIDTH (32), <xhtml:br/> .REGISTER_DEFAULT (1224) // Incorrect Default value used bit 0 is 0. <xhtml:br/>) Insecure_Device_ID_1 ( <xhtml:br/> .Data_in (Data_in), <xhtml:br/> .Data_out (Secure_reg), <xhtml:br/> .Clk (Clk), <xhtml:br/> .resetn (resetn), <xhtml:br/> .write (write) <xhtml:br/>); <xhtml:br/>
                            <xhtml:br/>register_example #( <xhtml:br/> .REGISTER_WIDTH (32) // Default not defined 2^32-2 value will be used as default. <xhtml:br/>) Insecure_Device_ID_2 ( <xhtml:br/> .Data_in (Data_in), <xhtml:br/> .Data_out (Insecure_reg), <xhtml:br/> .Clk (Clk), <xhtml:br/> .resetn (resetn), <xhtml:br/> .write (write) <xhtml:br/>); <xhtml:br/>
                            <xhtml:br/>endmodule <xhtml:br/></xhtml:div>
                    </Example_Code>
                    <Body_Text>These example instantiations show how, in a hardware design, it would be possible to instantiate the register module with insecure defaults and parameters.</Body_Text>
                    <Body_Text>In the example design, both registers will be software writable since Secure_mode is defined as zero. </Body_Text>
                    <Example_Code Nature="informative">
                        <xhtml:div>register_example #( <xhtml:br/> .REGISTER_WIDTH (32), <xhtml:br/> .REGISTER_DEFAULT (1225) // Correct default value set, to enable Secure_mode <xhtml:br/>) Secure_Device_ID_example ( <xhtml:br/> .Data_in (Data_in), <xhtml:br/> .Data_out (Secure_reg), <xhtml:br/> .Clk (Clk), <xhtml:br/> .resetn (resetn), <xhtml:br/> .write (write) <xhtml:br/>); </xhtml:div>
                    </Example_Code>
                </Demonstrative_Example>
            </Demonstrative_Examples>
            <Content_History>
                <Submission>
                    <Submission_Name>Hareesh Khattri</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
					<Submission_Date>2019-12-12</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1223" Name="Race Condition for Write-Once Attributes" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>A write-once register in hardware design is programmable by an untrusted software component earlier than the trusted software component, resulting in a race condition issue.</Description>
            <Extended_Description>
                <xhtml:p>Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to defined default values that are hard coded in the hardware description language (HDL) code of the hardware unit. A common security protection method used to protect register settings from modification by software is to make them write-once. This means the hardware implementation only allows writing to such registers once, and they become read-only after having been written once by software. This is useful to allow initial boot software to configure systems settings to secure values while blocking runtime software from modifying such hardware settings.</xhtml:p>
                <xhtml:p>Implementation issues in hardware design of such controls can expose such registers to a race condition security flaw. For example, consider a hardware design that has two different software/firmware modules executing in parallel. One module is trusted (module A) and another is untrusted (module B). In this design it could be possible for Module B to send write cycles to the write-once register before Module A. Since the field is write-once the programmed value from Module A will be ignored and the pre-empted value programmed by Module B will be used by hardware.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="362" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Name="Verilog" Prevalence="Undetermined"/>
                <Language Name="VHDL" Prevalence="Undetermined"/>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                    <Note>This weakness can appear in designs that use register write-once attributes with two or more software/firmware modules with varying levels of trust executing in parallel.</Note>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Access Control</Scope>
                    <Impact>Bypass Protection Mechanism</Impact>
                    <Note>System configuration cannot be programmed in a secure way</Note>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Description>During hardware design all register write-once or sticky fields must be evaluated for proper configuration.</Description>
                </Mitigation>
                <Mitigation>
                    <Phase>Testing</Phase>
                    <Description>The testing phase should use automated tools to test that values are not reprogrammable and that write-once fields lock on writing zeros.</Description>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>consider the example design module system verilog code shown below. register_write_once_example module is an example of register that has a write-once field defined. Bit 0 field captures the write_once_status value.</Intro_Text>
                    <Example_Code Nature="bad" Language="Verilog">
                        <xhtml:div>module register_write_once_example <xhtml:br/>( <xhtml:br/>input [15:0] Data_in, <xhtml:br/>input Clk, <xhtml:br/>input ip_resetn, <xhtml:br/>input global_resetn, <xhtml:br/>input write, <xhtml:br/>output reg [15:0] Data_out <xhtml:br/>); <xhtml:br/>
                            <xhtml:br/>reg Write_once_status; <xhtml:br/>
                            <xhtml:br/>always @(posedge Clk or negedge ip_resetn) <xhtml:br/> if (~ip_resetn) <xhtml:br/> begin <xhtml:br/> Data_out &lt;= 16'h0000; <xhtml:br/> Write_once_status &lt;= 1'b0; <xhtml:br/> end <xhtml:br/> else if (write &amp; ~Write_once_status) <xhtml:br/> begin <xhtml:br/> Data_out &lt;= Data_in &amp; 16'hFFFE; // Input data written to register after masking bit 0 <xhtml:br/> Write_once_status &lt;= 1'b1; // Write once status set after first write. <xhtml:br/> end <xhtml:br/> else if (~write) <xhtml:br/> begin <xhtml:br/> Data_out[15:1] &lt;= Data_out[15:1]; <xhtml:br/> Data_out[0] &lt;= Write_once_status; <xhtml:br/> end <xhtml:br/>
                            <xhtml:br/>endmodule </xhtml:div>
                    </Example_Code>
                    <Body_Text>The first system component that sends a write cycle to this register can program the value. This could result in a race condition security issue in SoC design, if an untrusted agent is running in the system in parallel with the trusted component that is expected to program the register.</Body_Text>
                    <Example_Code Nature="informative">
                        <xhtml:div>Trusted firmware or software trying to set the write-once field. <xhtml:br/> - Must confirm the Write_once_status (bit 0) value is zero, before programming register. If another agent has programmed the register before, then Write_once_status value will be one. <xhtml:br/> - After writing to the register, the trusted software can issue a read to confirm that the valid setting has been programmed. </xhtml:div>
                    </Example_Code>
                </Demonstrative_Example>
            </Demonstrative_Examples>
            <Content_History>
                <Submission>
                    <Submission_Name>Hareesh Khattri</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
					<Submission_Date>2019-12-12</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1224" Name="Improper Restriction of Write-Once Bit Fields" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The hardware design control register "sticky bits" or write-once bit fields are improperly implemented, such that they can be reprogrammed by software.</Description>
            <Extended_Description>
                <xhtml:p>Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to define default values that are hard coded in the hardware description language (HDL) code of the hardware unit. A common security protection method used to protect register settings from modification by software is to make the settings write-once or "sticky." This allows writing to such registers only once, whereupon they become read-only. This is useful to allow initial boot software to configure systems settings to secure values while blocking runtime software from modifying such hardware settings.</xhtml:p>
                <xhtml:p>Failure to implement write-once restrictions in hardware design can expose such registers to being re-programmed by software and written multiple times. For example, write-once fields could be implemented to only be write-protected if they have been set to value "1", wherein they would work as "write-1-once" and not "write-once".</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="284" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Name="Verilog" Prevalence="Undetermined"/>
                <Language Name="VHDL" Prevalence="Undetermined"/>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                </Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                    <Note>Such issues could be introduced during implementation of hardware design, since IP parameters and defaults are defined in HDL code and identified later during Testing or System Configuration phases.</Note>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Confidentiality</Scope>
                    <Scope>Integrity</Scope>
                    <Scope>Availability</Scope>
                    <Scope>Access Control</Scope>
                    <Impact>Varies by Context</Impact>
                    <Note>System configuration cannot be programmed in a secure way</Note>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Description>During hardware design all register write-once or sticky fields must be evaluated for proper configuration.</Description>
                </Mitigation>
                <Mitigation>
                    <Phase>Testing</Phase>
                    <Description>The testing phase should use automated tools to test that values are not reprogrammable and that write-once fields lock on writing zeros.</Description>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>Consider the example design module system verilog code shown below. register_write_once_example module is an example of register that has a write-once field defined. Bit 0 field captures the write_once_status value. This implementation can be for a register that is defined by specification to be a write-once register, since the write_once_status field gets written by input data bit 0 on first write. </Intro_Text>
                    <Example_Code Nature="bad" Language="Verilog">
                        <xhtml:div>module register_write_once_example <xhtml:br/>( <xhtml:br/>input [15:0] Data_in, <xhtml:br/>input Clk, <xhtml:br/>input ip_resetn, <xhtml:br/>input global_resetn, <xhtml:br/>input write, <xhtml:br/>output reg [15:0] Data_out <xhtml:br/>); <xhtml:br/>
                            <xhtml:br/>reg Write_once_status; <xhtml:br/>
                            <xhtml:br/>always @(posedge Clk or negedge ip_resetn) <xhtml:br/> if (~ip_resetn) <xhtml:br/> begin <xhtml:br/> Data_out &lt;= 16'h0000; <xhtml:br/> Write_once_status &lt;= 1'b0; <xhtml:br/> end <xhtml:br/> else if (write &amp; ~Write_once_status) <xhtml:br/> begin <xhtml:br/> Data_out &lt;= Data_in &amp; 16'hFFFE; <xhtml:br/> Write_once_status &lt;= Data_in[0]; // Input bit 0 sets Write_once_status <xhtml:br/> end <xhtml:br/> else if (~write) <xhtml:br/> begin <xhtml:br/> Data_out[15:1] &lt;= Data_out[15:1]; <xhtml:br/> Data_out[0] &lt;= Write_once_status; <xhtml:br/> end <xhtml:br/>
                            <xhtml:br/>endmodule </xhtml:div>
                    </Example_Code>
                    <Body_Text>The above example only locks further writes if write_once_status bit is written to one. So it acts as write_1-Once instead of the write-once attribute.</Body_Text>
                    <Example_Code Nature="informative">
                        <xhtml:div>module register_write_once_example <xhtml:br/>( <xhtml:br/>input [15:0] Data_in, <xhtml:br/>input Clk, <xhtml:br/>input ip_resetn, <xhtml:br/>input global_resetn, <xhtml:br/>input write, <xhtml:br/>output reg [15:0] Data_out <xhtml:br/>); <xhtml:br/>
                            <xhtml:br/>reg Write_once_status; <xhtml:br/>
                            <xhtml:br/>always @(posedge Clk or negedge ip_resetn) <xhtml:br/> if (~ip_resetn) <xhtml:br/> begin <xhtml:br/> Data_out &lt;= 16'h0000; <xhtml:br/> Write_once_status &lt;= 1'b0; <xhtml:br/> end <xhtml:br/> else if (write &amp; ~Write_once_status) <xhtml:br/> begin <xhtml:br/> Data_out &lt;= Data_in &amp; 16'hFFFE; <xhtml:br/> Write_once_status &lt;= 1'b1; // Write once status set on first write, independent of input <xhtml:br/> end <xhtml:br/> else if (~write) <xhtml:br/> begin <xhtml:br/> Data_out[15:1] &lt;= Data_out[15:1]; <xhtml:br/> Data_out[0] &lt;= Write_once_status; <xhtml:br/> end <xhtml:br/>
                            <xhtml:br/>endmodule </xhtml:div>
                    </Example_Code>
                </Demonstrative_Example>
            </Demonstrative_Examples>
            <Content_History>
                <Submission>
                    <Submission_Name>Hareesh Khattri</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
					<Submission_Date>2019-12-12</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1231" Name="Improper Implementation of Lock Protection Registers" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The product incorrectly implements register lock bit protection features such that protected controls can be programmed even after the lock has been set.</Description>
            <Extended_Description>
                <xhtml:p>In integrated circuits and hardware IPs, device configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set disables writes to a protected set of registers or address regions. Design or coding errors in the implementation of the lock bit protection feature may allow the lock bit to be modified or cleared by software after being set to unlock the system.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="284" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Class="Technology-Independent" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                    <Note>Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.</Note>
                </Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                    <Note>Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.</Note>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Access Control</Scope>
                    <Impact>Modify Memory</Impact>
                    <Likelihood>High</Likelihood>
                    <Note>Registers protected by lock bit can be modified even when lock is set.</Note>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Phase>Testing</Phase>
                    <Description>
                        <xhtml:ul>
                            <xhtml:li>Security lock bit protections must be reviewed for design inconsistency and common weaknesses.</xhtml:li>
                            <xhtml:li>Security lock programming flow and lock properties must be tested in pre-silicon, post-silicon testing.</xhtml:li>
                        </xhtml:ul>
                    </Description>
                    <Effectiveness>High</Effectiveness>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>Consider the example design below or a digital thermal sensor used in the design to detect overheating of the silicon and trigger system shutdown. The system critical temperature limit (CRITICAL_TEMP_LIMIT) and thermal sensor calibration (TEMP_SENSOR_CALIB) data have to be programmed by firmware and then the register needs to be locked (TEMP_SENSOR_LOCK).</Intro_Text>
                    <Example_Code Nature="bad" Language="Other">
                        <xhtml:table>
                            <xhtml:tr>
                                <xhtml:th>Register</xhtml:th>
                                <xhtml:th>Field description</xhtml:th>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>CRITICAL_TEMP_LIMIT</xhtml:td>
                                <xhtml:td>[31:8] Reserved field; Read only; Default 0<xhtml:br/>[7:0] Critical temp 0-255 Centigrade; Read-write-lock; Default 125</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>TEMP_SENSOR_CALIB</xhtml:td>
                                <xhtml:td>[31:0] Thermal sensor calibration data. Slope value used to map sensor reading to degree Centigrade.</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>TEMP_SENSOR_LOCK</xhtml:td>
                                <xhtml:td>[31:1] Reserved field; Read only; Default 0<xhtml:br/>[0] Lock bit, locks CRITICAL_TEMP_LIMIT and TEMP_SENSOR_CALIB registers; Write-1-once; Default 0</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>TEMP_HW_SHUTDOWN</xhtml:td>
                                <xhtml:td>[31:2] Reserved field; Read only; Default 0<xhtml:br/>[1] Enable hardware shutdown on critical temperature detection; Read-write; Default 0</xhtml:td>
                            </xhtml:tr>
                            <xhtml:tr>
                                <xhtml:td>CURRENT_TEMP</xhtml:td>
                                <xhtml:td> [31:8] Reserved field; Read only; Default 0<xhtml:br/>[7:0] Current Temp 0-255 Centigrade; Read-only; Default 0</xhtml:td>
                            </xhtml:tr>
                        </xhtml:table>
                    </Example_Code>
                    <Body_Text>In this example note that the response of the system if the system heats to critical temperature is controlled by TEMP_HW_SHUTDOWN bit [1], which is not lockable. Thus, the intended security property of the critical temperature sensor cannot be fully protected,since software can misconfigure the TEMP_HW_SHUTDOWN register even after the lock bit is set to disable the shutdown response.</Body_Text>
                    <Example_Code Nature="mitigation">
                        <xhtml:p>Change TEMP_HW_SHUTDOWN field to be locked by TEMP_SENSOR_LOCK.</xhtml:p>
                        <xhtml:table>
                            <xhtml:tr>
                                <xhtml:td>TEMP_HW_SHUTDOWN</xhtml:td>
                                <xhtml:td>[31:2] Reserved field; Read only; Default 0 <xhtml:br/>[1] Enable hardware shutdown on critical temperature detection; Read-write-Lock; Default 0<xhtml:br/>[0] Locked by TEMP_SENSOR_LOCK</xhtml:td>
                            </xhtml:tr>
                        </xhtml:table>
                    </Example_Code>
                </Demonstrative_Example>
            </Demonstrative_Examples>
            <Content_History>
                <Submission>
                    <Submission_Name>Hareesh Khattri</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-01-15</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1232" Name="Improper Lock Behavior After Power State Transition" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The product implements register lock bit protection features with the intent to disable changes to system configuration after the lock is set. Some of the protected registers or lock bits become programmable after power state transitions (e.g., Entry and wake from low power sleep modes).</Description>
            <Extended_Description>
                <xhtml:p>Integrated circuits and hardware IPs can expose the device configuration controls that need to be programmed after device power reset by a trusted firmware or software module (commonly set by BIOS/bootloader) and then locked from any further modification. In hardware design this is commonly implemented using a programmable lock bit, which when set disables writes to a protected set of registers or address regions.</xhtml:p>
                <xhtml:p>Some common weaknesses that can exist in such a protection scheme is that the lock gets cleared, the values of the protected registers get reset, or the lock become programmable after a power state transition.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="667" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Class="Technology-Independent" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                    <Note>Such issues could be introduced during hardware architecture and design or implementation and identified later during Testing or System Configuration phases.</Note>
                </Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                    <Note>Such issues could be introduced during hardware architecture and design or implementation and identified later during Testing or System Configuration phases.</Note>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Access Control</Scope>
                    <Impact>Modify Memory</Impact>
                    <Likelihood>High</Likelihood>
                    <Note>System Configuration protected by lock bit can be modified even when lock is set.</Note>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Phase>Testing</Phase>
                    <Description>
                        <xhtml:ul>
                            <xhtml:li>Security Lock bit protections must be reviewed for behavior across supported power state transitions.</xhtml:li>
                            <xhtml:li>Security lock programming flow and lock properties must be tested in pre-si, post-si testing, including testing these across power transitions.</xhtml:li>
                        </xhtml:ul>
                    </Description>
                    <Effectiveness>High</Effectiveness>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>
                        <xhtml:p>Consider memory configuration settings of a system that uses DDR3 DRAM memory. Protecting the DRAM memory configuration from modification by software is required to ensure that system memory access control protections cannot be bypassed. This can be done by using a lock bit protection that locks all memory configuration registers. The memory configuration lock can be set by BIOS on boot.</xhtml:p>
                        <xhtml:p>If such a system also supports a low power sleep state like hibernate, the DRAM data must be saved in disk and restored when system resumes from hibernate. During hibernate, system DRAM would be powered off.</xhtml:p>
                    </Intro_Text>
                    <Body_Text>To support hibernate power transition flow, the DRAM memory configuration must be reprogrammed even though it was locked previously.  During hibernate resume, the memory configuration could be modified or memory lock cleared.</Body_Text>
                    <Body_Text>Functionally the hibernate resume flow requires a bypass of the lock-based protection.</Body_Text>
                    <Body_Text>The memory configuration must be securely stored and restored by trusted system firmware. Lock settings and system configuration must be restored to same state as before entry to hibernate mode.</Body_Text>
                </Demonstrative_Example>
            </Demonstrative_Examples>
            <Content_History>
                <Submission>
                    <Submission_Name>Hareesh Khattri</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-01-15</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1233" Name="Improper Hardware Lock Protection for Security Sensitive Controls" Abstraction="Base" Structure="Simple" Status="Incomplete">
         <Description>The product implements a register lock bit protection feature that permits security sensitive controls to modify the protected configuration.</Description>
         <Extended_Description>
         	<xhtml:p>Integrated circuits and hardware IPs can expose the device configuration controls that need to be programmed after device power reset by a trusted firmware or software module (commonly set by BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set disables writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). If any system registers/controls that can modify the protected configuration are not write-protected by the lock,  they can then be leveraged by software to modify the protected configuration.</xhtml:p>
		</Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="667" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
         <Applicable_Platforms>
            <Language Class="Language-Independent" Prevalence="Undetermined"/>
			<Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
			<Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
			<Technology Class="Technology-Independent" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
               <Note>Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.</Note>
            </Introduction>
            <Introduction>
               <Phase>Implementation</Phase>
               <Note>Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.</Note>
            </Introduction>
         </Modes_Of_Introduction>
         <Common_Consequences>
            <Consequence>
               <Scope>Access Control</Scope>
			   <Impact>Modify Memory</Impact>
               <Note>System Configuration protected by the lock bit can be modified even when the lock is set.</Note>
            </Consequence>
         </Common_Consequences>
         <Potential_Mitigations>
            <Mitigation>
               <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Phase>Testing</Phase>
                    <Description>
                        <xhtml:ul>
                            <xhtml:li>Security lock bit protections must be reviewed for design inconsistency and common weaknesses.</xhtml:li>
                            <xhtml:li>Security lock bit protections must be reviewed common weaknesses.</xhtml:li>
							<xhtml:li>Security lock programming flow and lock properties must be tested in pre-si, post-si testing.</xhtml:li>
                        </xhtml:ul>
                    </Description>
            </Mitigation>
         </Potential_Mitigations>
         <Demonstrative_Examples>
            <Demonstrative_Example>
               <Intro_Text>For example, consider the example design below or a digital thermal sensor used in the design to detect overheating of the silicon to trigger a system shutdown. The system critical temperature limit (CRITICAL_TEMP_LIMIT) and thermal sensor calibration (TEMP_SENSOR_CALIB) data have to be programmed by the firmware. 
               </Intro_Text>
               <Example_Code Nature="bad" Language="Other">
				<xhtml:table>
				    <xhtml:tr>
				        <xhtml:th>Register</xhtml:th>
				        <xhtml:th>Field description</xhtml:th>
				    </xhtml:tr>
				<xhtml:tr>
				  <xhtml:td>CRITICAL_TEMP_LIMIT
				  </xhtml:td>
				  <xhtml:td>[31:8]<xhtml:br/> Reserved field;<xhtml:br/> Read only;<xhtml:br/> Default 0<xhtml:br/>[7:0]<xhtml:br/> Critical temp 0-255 Centigrade;<xhtml:br/> Read-write-lock; Default 125<xhtml:br/>
				  </xhtml:td>
				  </xhtml:tr>
				  <xhtml:tr>
				  <xhtml:td>TEMP_SENSOR_CALIB
				  </xhtml:td>
				  <xhtml:td>[31:0]<xhtml:br/> Thermal sensor calibration data. A slope value used to map sensor reading to a degree Centigrade.<xhtml:br/> Read-write;<xhtml:br/> Default 25<xhtml:br/>
				  </xhtml:td>
				  </xhtml:tr>
				  <xhtml:tr>
				  <xhtml:td>TEMP_SENSOR_LOCK
				  </xhtml:td>
				  <xhtml:td>[31:1]<xhtml:br/> Reserved field;<xhtml:br/> Read only;<xhtml:br/> Default 0 [0]   Lock bit, locks CRITICAL_TEMP_LIMIT register;<xhtml:br/>Write-1-once;<xhtml:br/> Default 0<xhtml:br/>
				  </xhtml:td>
				  </xhtml:tr>
				  <xhtml:tr>
				  <xhtml:td>TEMP_HW_SHUTDOWN
				  </xhtml:td>
				  <xhtml:td>[31:2]<xhtml:br/> Reserved field;<xhtml:br/> Read only;<xhtml:br/> Default 0 [1] Enable hardware shutdown on a critical temperature detection;<xhtml:br/> Read-write;<xhtml:br/> Default 0<xhtml:br/>
				  </xhtml:td>
				  </xhtml:tr>
				  <xhtml:tr>
				  <xhtml:td>CURRENT_TEMP
				  </xhtml:td>
				  <xhtml:td> [31:8]<xhtml:br/> Reserved field;<xhtml:br/> Read only;<xhtml:br/> Default 0<xhtml:br/>[7:0]<xhtml:br/>   Current Temp 0-255 Centigrade;<xhtml:br/> Read-only;<xhtml:br/> Default 0<xhtml:br/> 
				  </xhtml:td>
				  </xhtml:tr>
				  </xhtml:table>
               </Example_Code>				  
			   <Body_Text>
			   <xhtml:p>In this example note that only the CRITICAL_TEMP_LIMIT register is protected by the TEMP_SENSOR_LOCK bit, while the security design intent is to protect any modification of the critical temperature detection and response. 
			   </xhtml:p>
			   <xhtml:p>The response of the system, if the system heats to a critical temperature, is controlled by TEMP_HW_SHUTDOWN bit [1], which is not lockable. Also, the TEMP_SENSOR_CALIB register is not protected by the lock bit.
			   </xhtml:p>
			   <xhtml:p>By modifying the temperature sensor calibration, the conversion of the sensor data to a degree centigrade can be changed, such that the current temperature will never be detected to exceed critical temperature value programmed by the protected lock.
			   </xhtml:p>
			   <xhtml:p>Similarly, by modifying the TEMP_HW_SHUTDOWN.Enable bit, the system response detection of the current temperature exceeding critical temperature can be disabled.
			   </xhtml:p>
			   </Body_Text>
			   <Example_Code Nature="informative"><xhtml:p>Change TEMP_HW_SHUTDOWN and TEMP_SENSOR_CALIB controls to be locked by TEMP_SENSOR_LOCK.
			   </xhtml:p>
			   <xhtml:table>
				<xhtml:tr>
				  <xhtml:td>TEMP_SENSOR_CALIB
				  </xhtml:td>
				  <xhtml:td>[31:8]<xhtml:br/>Thermal sensor calibration data. A slope value used to map sensor reading to a degree Centigrade.<xhtml:br/> Read-write-Lock;<xhtml:br/> Default 25<xhtml:br/> Locked by TEMP_SENSOR_LOCK bit[0]<xhtml:br/>
				  </xhtml:td>
				  </xhtml:tr>
				  <xhtml:tr>
				  <xhtml:td>TEMP_HW_SHUTDOWN
				  </xhtml:td>
				  <xhtml:td>[31:2]<xhtml:br/> Reserved field;<xhtml:br/> Read only;<xhtml:br/> Default 0<xhtml:br/>[1] Enable hardware shutdown on critical temperature detection;<xhtml:br/> Read-write-Lock;<xhtml:br/> Default 0<xhtml:br/>Locked by TEMP_SENSOR_LOCK bit[0]<xhtml:br/>
				  </xhtml:td>
				  </xhtml:tr>
				  </xhtml:table>
               </Example_Code>
            </Demonstrative_Example>
         </Demonstrative_Examples>
		 <Content_History>
            <Submission>
                <Submission_Name>Hareesh Khattri</Submission_Name>
                <Submission_Organization>Intel Corporation</Submission_Organization>
                <Submission_Date>2020-01-15</Submission_Date>
            </Submission>
         </Content_History>
      </Weakness>
      <Weakness ID="1234" Name="Hardware Internal or Debug Modes Allow Override of Locks" Abstraction="Base" Structure="Simple" Status="Incomplete">
         <Description>The product implements register lock bit protection features that may permit security sensitive controls to modify system configuration after the lock is set through internal modes or debug features.</Description>
         <Extended_Description>
         	<xhtml:p>In integrated circuits and hardware IPs, device configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set disables writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). If debug features supported by hardware or internal modes/system states are supported in the hardware design, they may allow modification of the lock protection. </xhtml:p>
		</Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="667" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
         <Applicable_Platforms>
           <Language Class="Language-Independent" Prevalence="Undetermined"/>
		   <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
           <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
           <Technology Class="Technology-Independent" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
               <Note>Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.</Note>
            </Introduction>
			<Introduction>
               <Phase>Implementation</Phase>
               <Note>Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.</Note>
            </Introduction>
         </Modes_Of_Introduction>
         <Common_Consequences>
            <Consequence>
               <Scope>Access Control</Scope>
               <Impact>Bypass Protection Mechanism</Impact>
               <Likelihood>High</Likelihood>
               <Note>System Configuration protected by lock bit can be modified even when lock is set.</Note>
            </Consequence>
         </Common_Consequences>
         <Potential_Mitigations>
            <Mitigation>
              <Phase>Architecture and Design</Phase>
              <Phase>Implementation</Phase>
              <Phase>Testing</Phase>
               <Description>
                 <xhtml:ul>
                   <xhtml:li>Security Lock bit protections must be reviewed for any bypass/override modes supported.</xhtml:li>
                   <xhtml:li>Any supported override modes either must be removed, or these modes should be protected using features like secure authenticated, authorized debug modes. </xhtml:li>
                   <xhtml:li>Security lock programming flow and lock properties must be tested in pre-si, post-si testing.</xhtml:li>
                 </xhtml:ul>
               </Description>
               <Effectiveness>High</Effectiveness>
            </Mitigation>
         </Potential_Mitigations>
         <Demonstrative_Examples>
            <Demonstrative_Example>
              <Intro_Text>
                  For example, consider the example Locked_override_register example.  This register module  supports a lock mode that blocks any writes after lock is set to 1.
                <xhtml:br/>
                  However, it also allows override of the lock protection when scan_mode or debug_unlocked modes are active.
               </Intro_Text>
               <Example_Code Nature="bad" Language="Verilog">
                 <xhtml:div>
                   <xhtml:br/>module Locked_register_example
                   <xhtml:br/>(
                   <xhtml:br/>input [15:0]       Data_in,
                   <xhtml:br/>input              Clk,
                   <xhtml:br/>input              resetn,
                   <xhtml:br/>input              write,
                   <xhtml:br/>input              Lock,
                   <xhtml:br/>input              scan_mode,
                   <xhtml:br/>input              debug_unlocked,
                   <xhtml:br/>output reg [15:0]  Data_out
                   <xhtml:br/>);
                   <xhtml:br/>
                   <xhtml:br/>reg lock_status;
                   <xhtml:br/>
                   <xhtml:br/>always @(posedge Clk or negedge resetn)
                   <xhtml:br/>if (~resetn)  // Register is reset resetn
                   <xhtml:br/> begin 
                   <xhtml:br/>   lock_status &lt;= 1'b0;
                   <xhtml:br/> end
                   <xhtml:br/> else if (Lock)
                   <xhtml:br/> begin
                   <xhtml:br/>	lock_status &lt;= 1'b1;
                   <xhtml:br/> end
                   <xhtml:br/> else if (~Lock)
                   <xhtml:br/> begin	
                   <xhtml:br/>    lock_status &lt;= lock_status
                   <xhtml:br/> end
                   <xhtml:br/> 
                   <xhtml:br/>always @(posedge Clk or negedge resetn)
                   <xhtml:br/> if (~resetn)  // Register is reset resetn
                   <xhtml:br/> begin 
                   <xhtml:br/>   Data_out &lt;= 16'h0000;
                   <xhtml:br/> end 
                   <xhtml:br/> else if (write &amp; (~lock_status | scan_mode | debug_unlocked) ) // Register protected by Lock bit input, overrides supported for scan_mode &amp; debug_unlocked
                   <xhtml:br/> begin
                   <xhtml:br/>   Data_out &lt;= Data_in; 
                   <xhtml:br/> end
                   <xhtml:br/> else if (~write)
                   <xhtml:br/> begin
                   <xhtml:br/>   Data_out &lt;= Data_out;
                   <xhtml:br/> end
                   <xhtml:br/>
                   <xhtml:br/>endmodule
                 </xhtml:div>
               </Example_Code>
               <Body_Text>If either of scan_mode or debug_unlocked modes can be triggered by software, then lock protection can be bypassed.  </Body_Text>
               <Example_Code Nature="good">
                   Remove debug and scan mode overrides. Or protect enabling of these modes through secure authentication and authorization features, such that only trusted and authorized users can enable these debug modes.
               </Example_Code>
            </Demonstrative_Example>
         </Demonstrative_Examples>
		 <Content_History>
            <Submission>
                <Submission_Name>Hareesh Khattri</Submission_Name>
                <Submission_Organization>Intel Corporation</Submission_Organization>
				<Submission_Date>2020-01-15</Submission_Date>
            </Submission>
         </Content_History>
      </Weakness>
      <Weakness ID="1240" Name="Use of a Risky Cryptographic Primitive" Abstraction="Base" Structure="Simple" Status="Draft">
            <Description>The product implements a cryptographic algorithm using a non-standard or unproven cryptographic primitive.</Description>
            <Extended_Description>
				<xhtml:p>Cryptographic algorithms (or Cryptographic systems) depend on cryptographic primitives as their basic building blocks. As a result, cryptographic primitives are designed to do one very specific task in a precisely defined and highly reliable fashion. For example, one can declare that a specific crypto primitive (like an encryption routine) can only be broken after trying out N different inputs (the larger the value of N, the stronger the crypto). If a vulnerability is found that leads to breaking this primitive in significantly less than N attempts, then the specific cryptographic primitive is considered broken, and the entirety of the cryptographic algorithm (or the cryptographic system) is now considered insecure. Thus, even breaking a seemingly small cryptographic primitive is sufficient to render the whole system vulnerable.</xhtml:p>
				<xhtml:p>Cryptographic primitives are products of extensive reviews from cryptographers, industry, and government entities looking for any possible flaws. However, over time even well-known cryptographic primitives lose their compliance status with emergence of novel attacks that might either defeat the algorithm or reduce its robustness significantly. If ad-hoc cryptographic primitives are implemented, it is almost certain that such implementation will be vulnerable to attacks resulting in the exposure of sensitive information and/or other consequences.</xhtml:p>
			</Extended_Description>
            <Related_Weaknesses>
              <Related_Weakness Nature="ChildOf" CWE_ID="327" View_ID="1000" Ordinal="Primary"/>
            </Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
            </Applicable_Platforms>
			<Background_Details>
				<Background_Detail>This issue is even more prominent for hardware-implemented deployment of cryptographic algorithms due to a number of reasons. Firstly, because hardware is not replaceable like software, if a flaw is discovered with a hardware-implemented cryptographic primitive, it cannot be fixed in most cases without a recall of the product. Secondly, the hardware product is often expected to work for years, during which time computation power available to the attacker only increases. Therefore, for hardware implementations of cryptographic primitives, it is absolutely essential that only strong, proven cryptographic primitives are used.</Background_Detail>
			</Background_Details>
			<Modes_Of_Introduction>
				<Introduction>
					<Phase>Architecture and Design</Phase>
					<Note>This weakness is primarily introduced during the architecture and design phase as risky primitives are included.</Note>
				</Introduction>
				<Introduction>
					<Phase>Implementation</Phase>
					<Note>In many cases, the design originally defines a proper cryptography primative, but this is then changed during implementation due to unforseen constraints.</Note>
				</Introduction>
			</Modes_Of_Introduction>
			<Common_Consequences>
				<Consequence>
					<Scope>Confidentiality</Scope>
					<Impact>Read Application Data</Impact>
					<Likelihood>High</Likelihood>
					<Note>Incorrect usage of crypto primitives could render the supposedly encrypted data as unencrypted plaintext in the worst case. This would compromise any security property, including the ones listed above.</Note>
				</Consequence>
			</Common_Consequences>
			<Potential_Mitigations>
				<Mitigation>
					<Phase>Architecture and Design</Phase>
					<Description>
						<xhtml:p>Follow these good cryptography practices:</xhtml:p>
						<xhtml:ul>
							<xhtml:li>Do not create your own crypto algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. As with all cryptographic mechanisms, the source code should be available for analysis. If the algorithm can be compromised when attackers find out how it works, then it is especially weak.</xhtml:li>
							<xhtml:li>Do not use outdated/not-compliant cryptography algorithms. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong.</xhtml:li>
							<xhtml:li>Do not use LFSR as a substitute for proper Random Number Generator IPs.</xhtml:li>
							<xhtml:li>Do not use checksum as a substitute for proper Hashes.</xhtml:li>
							<xhtml:li>Design the hardware at the IP level so that one cryptographic algorithm can be replaced with another in the next generation. Use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms.</xhtml:li>
							<xhtml:li>Do not store keys in areas accessible to untrusted agents. Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.</xhtml:li>
							<xhtml:li>Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Industry-standard implementations will save development time and might be more likely to avoid errors that can occur during implementation of cryptographic algorithms.</xhtml:li>
							<xhtml:li>When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.</xhtml:li>
						</xhtml:ul>
					</Description>
					<Effectiveness>High</Effectiveness>
				</Mitigation>
			</Potential_Mitigations>
			<Demonstrative_Examples>
				<Demonstrative_Example>
					<Intro_Text>Re-using Crypto primitive could compromise security</Intro_Text>
					<Example_Code Nature="bad">Suppose a Hashing algorithm needs random seed. Instead of using a DRNG (Deterministic Random Number Generator), the designer uses a LFSR to generate the seed.</Example_Code>
					<Body_Text>While an LFSR does provide pseudo-random number generation service, its entropy (measure of randomness) is less than that of a DRNG. Thus, using an LFSR weakens the strength of the crypto.</Body_Text>
					<Example_Code Nature="good">If a crypto expect a proper (or deterministic) random number as its input, do equip it with one - do not give it something that is pseudo-random.</Example_Code>
				</Demonstrative_Example>
			</Demonstrative_Examples>
			<Content_History>
                <Submission>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
					<Submission_Date>2020-02-10</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1241" Name="Use of Predictable Algorithm in Random Number Generator" Abstraction="Base" Structure="Simple" Status="Draft">
            <Description>The product requires a true random number but uses an algorithm that is predictable and generates a pseudo-random number.</Description>
            <Related_Weaknesses>
              <Related_Weakness Nature="ChildOf" CWE_ID="330" View_ID="1000" Ordinal="Primary"/>
            </Related_Weaknesses>
            <Applicable_Platforms>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
            </Applicable_Platforms>
			<Modes_Of_Introduction>
				<Introduction>
					<Phase>Architecture and Design</Phase>
					<Note>This weakness is primarily introduced during the architecture and design phase an incorrect algorithm is defined.</Note>
				</Introduction>
				<Introduction>
					<Phase>Implementation</Phase>
					<Note>In many cases, the design originally defines a proper cryptography primative, but this is then changed during implementation due to unforseen constraints.</Note>
				</Introduction>
			</Modes_Of_Introduction>
			<Common_Consequences>
				<Consequence>
					<Scope>Confidentiality</Scope>
					<Impact>Read Application Data</Impact>
					<Likelihood>High</Likelihood>
					<Note>Predicatable random numbers can render the protection mechanisms in place ineffective</Note>
				</Consequence>
			</Common_Consequences>
			<Potential_Mitigations>
				<Mitigation>
					<Phase>Architecture and Design</Phase>
					<Description>Leverage well-known true random number generation techniques.
					</Description>
					<Effectiveness>High</Effectiveness>
				</Mitigation>
			</Potential_Mitigations>
			<Demonstrative_Examples>
				<Demonstrative_Example>
					<Intro_Text>Suppose a cryptographic function expects to begin with a random seed.</Intro_Text>
					<Body_Text>During the implementation phase, due to space constraint, a proper random-number-generator could not be used, and instead  of using a DRNG (Deterministic Random Number Generator), the designer uses a LFSR (Linear Feedback Shift Register)to generate the seed. While an LFSR does provide pseudo-random number generation service, its entropy (measure of randomness) is less than that of a DRNG. Thus, using an LFSR weakens the strength of the crypto.This lack of entropy would weaken the overall crypto.</Body_Text>
				</Demonstrative_Example>
			</Demonstrative_Examples>
			<Content_History>
                <Submission>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
					<Submission_Date>2020-02-10</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1242" Name="Inclusion of Undocumented Features or Chicken Bits" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The chip includes chicken bits or undocumented features that can create entry points for unauthorized actors.</Description>
            <Extended_Description>
                <xhtml:p>A common design practice is to use "chicken bits," which are bits on a chip that can be used to disable certain functional security features. They can facilitate quick identification and isolation of faulty components, features that negatively affect performance, or features that do not provide the required controllability for debug and test. Another way to achieve this is through implementation of undocumented features. An attacker might exploit these interfaces for unauthorized access.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
              <Related_Weakness Nature="ChildOf" CWE_ID="284" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                </Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                </Introduction>
                <Introduction>
                    <Phase>Documentation</Phase>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Confidentiality</Scope>
                    <Scope>Integrity</Scope>
                    <Scope>Availability</Scope>
                    <Scope>Access Control</Scope>
                    <Impact>Modify Memory</Impact>
                    <Impact>Read Memory</Impact>
                    <Impact>Execute Unauthorized Code or Commands</Impact>
                    <Impact>Gain Privileges or Assume Identity</Impact>
                    <Impact>Bypass Protection Mechanism</Impact>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Description>
                        <xhtml:p>Do not implement chicken bits. If implemented, ensure that they are disabled in production devices. Document all interfaces to the chip.</xhtml:p>                     
                    </Description>
                    <Effectiveness>High</Effectiveness>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>Consider a chip that comes with various, security measures, such as secure boot. The secure-boot process performs firmware-integrity verification at boot time, and this code is stored in a separate SPI-flash chip. However, this code contains undocumented "special access features" intended to be used for performing failure analysis and can only be unlocked by the chip designer.</Intro_Text>
                    <Example_Code Nature="bad" Language="Other">
                        <xhtml:div>Attackers dump the code from the chip and then perform reverse engineering to analyze the code. The undocumented, special-access features are identified, and attackers can activate them by sending specific commands via UART before secure-boot phase completes. Using these hidden features, attackers can perform reads and writes to memory via the UART interface. At runtime, the attackers can also execute arbitrary code and dump the entire memory contents.</xhtml:div>
                    </Example_Code>
                    <Body_Text>Remove all chicken bits and hidden features that are exposed to attackers. Add authorization schemes that rely on cryptographic primitives to access any features that the manufacturer does not want to expose. Clearly document all interfaces.</Body_Text>
            	</Demonstrative_Example>
            </Demonstrative_Examples>
            <References>
                <Reference External_Reference_ID="REF-1071"/>
                <Reference External_Reference_ID="REF-1072"/>
                <Reference External_Reference_ID="REF-1073"/>
                <Reference External_Reference_ID="REF-1074"/>
                <Reference External_Reference_ID="REF-1075"/>
            </References>
            <Content_History>
                <Submission>
                    <Submission_Name>Arun Kanuparthi</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-02-13</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1243" Name="Exposure of Security-Sensitive Fuse Values During Debug" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The product exposes security-sensitive values stored in fuses during debug.</Description>
            <Extended_Description>
                <xhtml:p>Several security-sensitive values are blown as fuses in a chip to be used during early-boot flows or later at runtime. Examples of these security-sensitive values include root keys, encryption keys, manufacturing-specific information, chip-manufacturer-specific information, and original-equipment-manufacturer (OEM) data. After the chip is powered on, these values are sensed from fuses and stored in temporary locations such as registers and local memories. These locations are typically access-control protected from untrusted agents capable of accessing them. Even to trusted agents, only read-access is provided. However, these locations are not blocked during debug flows, allowing an untrusted debugger to access these assets and compromise system security.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="200" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                </Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Confidentiality</Scope>
                    <Scope>Access Control</Scope>
                    <Impact>Modify Memory</Impact>
                    <Impact>Bypass Protection Mechanism</Impact>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Description>
                        <xhtml:p>When in debug mode, disable access to security-sensitive values sensed from fuses and stored in temporary locations.</xhtml:p>                     
                    </Description>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>Secret manufacturing data (such as die information) are stored in fuses. While the chip powers on, this value is sensed from fuses and is stored in a microarchitectural register. This register is only given read access to trusted software running on the core. Untrusted software running on the core cannot access it.</Intro_Text>
                    <Example_Code Nature="bad" Language="Other">
                        <xhtml:div>All microarchitectural registers in this chip can be accessed through the debug interface. As a result, even an untrusted debugger can access this data and get hold of secret manufacturing data.</xhtml:div>
                    </Example_Code>
                	<Example_Code Nature="informative">
                  		<xhtml:div>Registers used to store security-sensitive values sensed from fuses should be blocked on debug. They should be disconnected from the debug interface.</xhtml:div>
               		</Example_Code>
            	</Demonstrative_Example>
            </Demonstrative_Examples>
            <Content_History>
                <Submission>
                    <Submission_Name>Arun Kanuparthi</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-02-12</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1244" Name="Improper Authorization on Physical Debug and Test Interfaces" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The product's physical debug and test interface protection does not block untrusted agents, resulting in unauthorized access to and potentially control of sensitive assets.</Description>
            <Extended_Description>
                <xhtml:p>If the product implements access-control protection on the debug and test interface, a debugger is typically required to enter either a valid response to a challenge provided by the authorization logic or, alternatively, enter the right password in order to exercise the debug and test interface. However, if this protection mechanism does not exclude all untrusted, debug agents, an attacker could access/control security-sensitive registers.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="285" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                </Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Confidentiality</Scope>
                    <Impact>Read Memory</Impact>
                </Consequence>
                <Consequence>
                    <Scope>Integrity</Scope>
                    <Impact>Modify Memory</Impact>
                </Consequence>
                <Consequence>
                    <Scope>Authorization</Scope>
                    <Scope>Access Control</Scope>
                    <Impact>Gain Privileges or Assume Identity</Impact>
                    <Impact>Bypass Protection Mechanism</Impact>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Description>
                        <xhtml:p>For security-sensitive assets accessible over debug/test interfaces, only allow trusted agents.</xhtml:p>                     
                    </Description>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>JTAG interface is used to perform debugging and providing insights into the CPU core for developers. JTAG-access protection is implemented as part of the JTAG_SHIELD bit in the register hw_digctl_ctrl REGISTER. This register is not set by default and is set after the system boots from ROM, and control is transferred to the user software.</Intro_Text>
                    <Example_Code Nature="bad" Language="Other">
                        <xhtml:table>
                            <xhtml:tbody>
                                <xhtml:tr>
                                    <xhtml:td>1 bit</xhtml:td>
                                    <xhtml:td>0x0 = JTAG debugger is enabled (default)</xhtml:td>
                                </xhtml:tr>
                                <xhtml:tr>
                                    <xhtml:td>JTAG_SHIELD</xhtml:td>
                                    <xhtml:td>0x1 = JTAG debugger is disabled</xhtml:td>
                                </xhtml:tr>
                            </xhtml:tbody>
                        </xhtml:table>
                    </Example_Code>
                    <Body_Text>This means that end user has access to JTAG at system reset and during ROM code execution before control is transferred to user software. With this loophole, an attacker can modify the boot flow and subsequently disclose data-encryption keys.</Body_Text>
                	<Example_Code Nature="informative">
                  		<xhtml:div>The default value of this register bit should be set to 1.  This prevents JTAG being enabled at system reset.</xhtml:div>
               		</Example_Code>
            	</Demonstrative_Example>
            </Demonstrative_Examples>
            <Observed_Examples>
            	<Observed_Example>
               		<Reference>CVE-2019-18827</Reference>
               		<Description>JTAG access is disabled after ROM code execution.  This means that JTAG access is possible when the system is running code from ROM before transferring control over to embedded firmware.  This allows an attacker to modify boot flow and successfully bypass secure-boot process.</Description>
               		<Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18827</Link>
           		 </Observed_Example>
           	</Observed_Examples>
            <References>
                <Reference External_Reference_ID="REF-1056"/>
                <Reference External_Reference_ID="REF-1057"/>
            </References>
            <Content_History>
                <Submission>
                    <Submission_Name>Arun Kanuparthi</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-02-12</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1245" Name="Improper Finite State Machines (FSMs) in Hardware Logic" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>Faulty finite state machines (FSMs) in the hardware logic allow an attacker to put the system in an undefined state, to cause a denial of service (DoS) or gain privileges on the victim's system.</Description>
            <Extended_Description>
                <xhtml:p>The functionality and security of the system heavily depend on the implementation of FSMs. FSMs can be used to indicate the current security state of the system. Lots of secure data operations and data transfers rely on the state reported by the FSM. Faulty FSM designs that do not account for all states, either through undefined states (left as don't cares) or through incorrect implementation, might lead an attacker to drive the system into an unstable state from which the system cannot recover without a reset, thus causing a DoS. Depending on what the FSM is used for, an attacker might also gain additional privileges to launch further attacks and compromise the security guarantees.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="684" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                </Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Availability</Scope>
                    <Scope>Access Control</Scope>
                    <Impact>Unexpected State</Impact>
                    <Impact>DoS: Crash, Exit, or Restart</Impact>
                    <Impact>DoS: Instability</Impact>
                    <Impact>Gain Privileges or Assume Identity</Impact>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Description>Define all possible states and handle all unused states through default statements. Ensure that system defaults to a secure state.</Description>
                    <Effectiveness>High</Effectiveness>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>The FSM shown in the "bad" code snippet below assigns the output out based on the value of state, which is determined based on the user provided input, user_input.</Intro_Text>
                    <Example_Code Nature="bad" Language="Verilog">
                        <xhtml:div>module fsm_1(out, user_input, clk, rst_n);
                            <xhtml:br/>input [2:0] user_input; 
                            <xhtml:br/>input clk, rst_n;
                            <xhtml:br/>output reg [2:0] out;
                            <xhtml:br/>reg [1:0] state;
                            <xhtml:br/>always @ (posedge clk or negedge rst_n )
                            <xhtml:br/>
                            <xhtml:div style="margin-left:10px;">begin
                                <xhtml:br/>
                                <xhtml:div style="margin-left:10px;">if (!rst_n)
                                    <xhtml:br/>state = 3'h0;
                                    <xhtml:br/>else
                                    <xhtml:br/>case (user_input)
                                    <xhtml:div style="margin-left:10px;">
                                        <xhtml:br/>3'h0:
                                        <xhtml:br/>3'h1:
                                        <xhtml:br/>3'h2:
                                        <xhtml:br/>3'h3: state = 2'h3;
                                        <xhtml:br/>3'h4: state = 2'h2;
                                        <xhtml:br/>3'h5: state = 2'h1;
                                    </xhtml:div>
                                    <xhtml:br/>endcase
                                </xhtml:div>
                                <xhtml:br/>end
                                <xhtml:br/>out &lt;= {1'h1, state};
                            </xhtml:div>
                            <xhtml:br/>endmodule
                        </xhtml:div>
                    </Example_Code>
                    <Body_Text>
                        <xhtml:p>The case statement does not handle the scenario when user provides inputs of 3'h6 and 3'h7 using a default statement.  Those inputs push the system to an undefined state and might cause a crash (denial of service) or any other unanticipated outcome.</xhtml:p>
                        <xhtml:p>Adding a default statement to handle undefined inputs mitigates this issue.  This is shown in the "Good" code snippet below.  The default statement is in bold.</xhtml:p>
                    </Body_Text>
                    <Example_Code Nature="good" Language="Other">
                        <xhtml:div>case (user_input)
                            <xhtml:br/><xhtml:div style="margin-left:10px;">3'h0:
                                <xhtml:br/>3'h1:
                                <xhtml:br/>3'h2:
                                <xhtml:br/>3'h3: state = 2'h3;
                                <xhtml:br/>3'h4: state = 2'h2;
                                <xhtml:br/>3'h5: state = 2'h1;
                                <xhtml:br/><xhtml:b>default: state = 2'h0;</xhtml:b>
                            </xhtml:div>
                            <xhtml:br/>endcase</xhtml:div>
                    </Example_Code>
            	</Demonstrative_Example>
            </Demonstrative_Examples>
            <References>
                <Reference External_Reference_ID="REF-1060"/>
            </References>
            <Content_History>
                <Submission>
                    <Submission_Name>Arun Kanuparthi</Submission_Name>
                    <Submission_Organization>The Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-02-12</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1246" Name="Improper Write Handling in Limited-write Non-Volatile Memories" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The product does not implement or incorrectly handles the implementation of write operations in limited-write non-volatile memories.</Description>
            <Extended_Description>
                <xhtml:p>Non-volatile memories such as NAND Flash, EEPROM, etc. have individually erasable segments, each of which can be put through a limited number of program/erase or write cycles. For example, the device can only endure a limited number of writes, after which the device becomes unreliable. In order to wear out the cells in a uniform manner, non-volatile memory and storage products based on the above-mentioned technologies implement a technique called wear leveling. Once a set threshold is reached, wear leveling maps writes of a logical block to a different physical block. This prevents a single physical block from prematurely failing due to a high concentration of writes. If wear leveling is improperly implemented, attackers can execute a write virus and cause the storage to become unreliable much faster than the minimally guaranteed platform lifetime.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="664" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
		<Technology Name="Memory IP" Prevalence="Undetermined"/>
		<Technology Name="Storage IP" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Architecture and Design</Phase>
                </Introduction>
                <Introduction>
                    <Phase>Implementation</Phase>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Availability</Scope>
                    <Impact>DoS: Instability</Impact>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
					<Phase>Testing</Phase>
                    <Description>
                        <xhtml:p>Include secure wear leveling algorithms and ensure that it cannot be bypassed by known write viruses.</xhtml:p>                     
                    </Description>
					<Effectiveness>High</Effectiveness>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>An adversary can render a memory line unusable by writing to it repeatedly.</Intro_Text>
                    <Body_Text>Below is example code from [REF-1058] that the user can execute repeatedly to cause line failure. W is the maximum associativity of any cache in the system; S is the size of the largest cache in the system.</Body_Text>
                    <Example_Code Nature="bad" Language="Other">
					<xhtml:div>Do aligned alloc of (W+1) arrays each of size S
					<xhtml:br/>
					<xhtml:div>while(1) {
					<xhtml:br/>
						<xhtml:div>for (ii = 0; i &lt; W + 1; ii++)
						<xhtml:div style="margin-left:10px;">
						  array[ii].element[0]++;
						  <xhtml:br/>
						</xhtml:div>
						</xhtml:div>
					</xhtml:div>
					}
					</xhtml:div>					
               </Example_Code>
                    <Body_Text>Without wear leveling, the above attack will be successful. Simple randomization of blocks will not suffice as instead of the original physical block, the randomized physical block will be worn out.</Body_Text>
                	<Example_Code Nature="informative">
                  		<xhtml:div>Wear leveling must be used to even out writes to the device.</xhtml:div>
               		</Example_Code>
            	</Demonstrative_Example>
            </Demonstrative_Examples>
            <References>
                <Reference External_Reference_ID="REF-1058"/>
                <Reference External_Reference_ID="REF-1059"/>
            </References>
            <Content_History>
                <Submission>
                    <Submission_Name>Arun Kanuparthi</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-02-10</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1247" Name="Missing Protection Against Voltage and Clock Glitches" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The product does not contain the necessary additional circuitry or sensors to detect and mitigate voltage and clock glitches.</Description>
            <Extended_Description>
                <xhtml:p>A product might support security features such as secure boot that are supported through hardware and firmware implementation. This involves establishing a chain of trust, starting with an immutable root of trust by checking the signature of the next stage (culminating with the OS and runtime software) against a golden value before transferring control. The intermediate stages typically set up the system in a secure state by configuring several access control settings. Similarly, any password-checking logic for exercising the debug interface, etc. can implemented in hardware, firmware, or both. This implementation needs to be robust against fault attacks such as voltage glitches and clock glitches that an attacker may leverage to compromise the system.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="703" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Class="System on Chip" Prevalence="Undetermined"/>
				<Technology Name="Power Management IP" Prevalence="Undetermined"/>
				<Technology Name="Clock/Counter IP" Prevalence="Undetermined"/>
				<Technology Name="Sensor IP" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Operation</Phase>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Confidentiality</Scope>
                    <Scope>Integrity</Scope>
                    <Scope>Availability</Scope>
                    <Scope>Access Control</Scope>
                    <Impact>Gain Privileges or Assume Identity</Impact>
                    <Impact>Bypass Protection Mechanism</Impact>
                    <Impact>Read Memory</Impact>
                    <Impact>Modify Memory</Impact>
                    <Impact>Execute Unauthorized Code or Commands</Impact>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Phase>Implementation</Phase>
                    <Description>
                        <xhtml:p>At the circuit-level, using Tunable Replica Circuits (TRCs) or special flip-flops such as Razor flip-flops helps mitigate glitches. At SoC or platform level, level sensors can be implemented to detect glitches. Implementing redundancy in security-sensitive code (e.g., where checks are performed) helps in mitigating glitches.</xhtml:p>                     
                    </Description>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>Below is a representative snippet of C code that is part of the secure-boot flow. A signature of the runtime-firmware image is calculated and compared against the golden value. If the signatures match, the bootloader loads runtime firmware.  If not, it is not loaded. If the underlying hardware executing this code does not contain any circuitry or sensors to detect voltage/clock glitches, an attacker might launch a fault-injection attack right when the signature check is happening (at the location marked with the comment), and it could bypass the signature-checking process.</Intro_Text>
                    <Example_Code Nature="bad" Language="Other">
                        <xhtml:div>...
                        <xhtml:br/>
                        <xhtml:br/>if (signature_matches) {   // &lt;-Glitch Here
                        <xhtml:br/>		load_runtime_firmware();
                        <xhtml:br/>}		
                        <xhtml:br/>else {
                        <xhtml:br/>		do_not_load_runtime_firmware();
                        <xhtml:br/>}
                        <xhtml:br/>	
                        <xhtml:br/>...
                        </xhtml:div>
                    </Example_Code>
                    <Body_Text>After bypassing secure boot, an attacker can gain access to system assets to which the attacker should not have access.</Body_Text>
                	<Example_Code Nature="informative">
                  		<xhtml:div>If the underlying hardware detects a voltage/clock glitch, the information can be used to prevent the glitch from being successful.</xhtml:div>
               		</Example_Code>
            	</Demonstrative_Example>
            </Demonstrative_Examples>
            <Observed_Examples>
            	<Observed_Example>
               		<Reference>CVE-2019-17391</Reference>
               		<Description>Lack of anti-glitch protections allows an attacker to launch physical attack to bypass secure boot and read protected eFuses.</Description>
               		<Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-17391</Link>
           		 </Observed_Example>
           	</Observed_Examples>
            <References>
                <Reference External_Reference_ID="REF-1061"/>
                <Reference External_Reference_ID="REF-1062"/>
                <Reference External_Reference_ID="REF-1063"/>
                <Reference External_Reference_ID="REF-1064"/>
                <Reference External_Reference_ID="REF-1065"/>
                <Reference External_Reference_ID="REF-1066"/>
            </References>
            <Content_History>
                <Submission>
                    <Submission_Name>Arun Kanuparthi</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-02-12</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1248" Name="Semiconductor Defects in Hardware Logic with Security-Sensitive Implications" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The security-sensitive hardware module contains semiconductor defects. </Description>
            <Extended_Description>
                <xhtml:p>A semiconductor device can fail for various reasons. While some are manufacturing and packaging defects, the rest are due to prolonged use or usage under extreme conditions. Some mechanisms that lead to semiconductor defects include encapsulation failure, die-attach failure, wire-bond failure, bulk-silicon defects, oxide-layer faults, aluminum-metal faults (including electromigration, corrosion of aluminum, etc.), and thermal/electrical stress. These defects manifest as faults on chip-internal signals or registers, have the effect of inputs, outputs, or intermediate signals being always 0 or always 1, and do not switch as expected. If such faults occur in security-sensitive hardware modules, security guarantees offered by the device will be compromised.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
				<Related_Weakness Nature="ChildOf" CWE_ID="693" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Class="Technology-Independent" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
                    <Phase>Manufacturing</Phase>
                </Introduction>
                <Introduction>
                    <Phase>Operation</Phase>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Availability</Scope>
                    <Scope>Access Control</Scope>
                    <Impact>DoS: Instability</Impact>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Testing</Phase>
                    <Description>
                        <xhtml:p>While semiconductor-manufacturing companies implement several mechanisms to continuously improve the semiconductor manufacturing process to ensure reduction of defects, some defects can only be fixed after manufacturing. Post-manufacturing testing of silicon die is critical. Fault models such as stuck-at-0 or stuck-at-1 must be used to develop post-manufacturing test cases and achieve good coverage. Once the silicon packaging is done, extensive post-silicon testing must be performed to ensure that hardware logic implementing security functionalities is defect-free.</xhtml:p>                     
                    </Description>
                </Mitigation>
                <Mitigation>
                    <Phase>Operation</Phase>
                    <Description>
                        <xhtml:p>Operating the hardware outside device specification, such as at extremely high temperatures, voltage, etc., accelerates semiconductor degradation and results in defects.  When these defects manifest as faults in security-critical, hardware modules, it results in compromise of security guarantees. Thus, operating the device within the specification is important.</xhtml:p>                     
                    </Description>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>The network-on-chip implements a firewall for access control to peripherals from all IP cores capable of mastering transactions.</Intro_Text>
                    <Example_Code Nature="bad" Language="Other">
                        <xhtml:div>A manufacturing defect in this logic manifests itself as a logical fault, which always sets the output of the filter to "allow" access.</xhtml:div>
                    </Example_Code>
                    <Body_Text>Post-manufacture testing must be performed to ensure that hardware logic implementing security functionalities is defect-free.</Body_Text>
            	</Demonstrative_Example>
            </Demonstrative_Examples>
            <References>
                <Reference External_Reference_ID="REF-1067"/>
                <Reference External_Reference_ID="REF-1068"/>
            </References>
            <Content_History>
                <Submission>
                    <Submission_Name>Arun Kanuparthi</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-02-12</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1251" Name="Mirrored Regions with Different Values" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The product's architecture mirrors regions without ensuring that their contents always stay in sync.</Description>
            <Extended_Description>
	      <xhtml:p>Having mirrored regions with different values might result in the exposure of sensitive information and/or other consequences, including loss of access control.</xhtml:p>
                <xhtml:p>Due to architectural and performance constraints, one might need to duplicate a resource. The most common example of doing this in computer architecture is the concept of cache, which keeps a "local" copy of the data element in memory, because the time to access the memory (which is located far off from the computing core) is significantly longer compared to the time it takes to access a local copy (cache). Thus, keeping a local copy of some distant entity provides significant performance improvement. Unfortunately, this improvement also comes with a downside, since the product needs to ensure that the local copy always mirrors the original copy truthfully.  If they get out of sync somehow, the computational result is no longer true.</xhtml:p>
		<xhtml:p>In designing hardware, memory is not the only thing that gets mirrored. There are many other entities that get mirrored, too: registers, memory regions, and, in some cases, even whole units. For example, for a multi-core processor, if every memory access from any of those tens of cores goes through a single memory-management unit (MMU) for security reasons, then the MMU becomes a performance bottleneck. In such cases, it might make sense to create duplicate, local MMUs that will serve only a subset of the cores of processors rather than all of them. These local copies are also called "shadow copies" or "mirrored copies."</xhtml:p>
		<xhtml:p>If the original resource that was being duplicated into these local copies never changed, the question of the local copies getting out of sync would not arise. Unfortunately, in many cases, the values inside the original copy change. For example, a memory range might be inaccessible during boot time, but once the boot process is over and the system is now in a stable state, that memory range may now be opened up for access. So, if a register(s) in the access-control unit stores the start and end addresses of the "accessible" memory chunks, those values would change after the boot process is over. Now, when the original copy changes, the mirrored copies must also change, and change fast.</xhtml:p>
		<xhtml:p>This situation of shadow-copy-possibly-out-of-sync-with-original-copy might occur as a result of multiple scenarios, including the following:
		</xhtml:p>
                  <xhtml:div style="margin-left:10px;">
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                          <xhtml:li>After the values in the original copy change, due to some reason the original copy does not send the "update" request to its shadow copies.</xhtml:li>
			    <xhtml:li>After the values in the original copy change, the original copy dutifully sends the "update" request to its shadow copies, but due to some reason the shadow copy does not "execute" this update request.</xhtml:li>
			    <xhtml:li>After the values in the original copy change, the original copy sends the "update" request to its shadow copies, and the shadow copy executes this update request faithfully. However, during the small time period when the original copy has "new" values and the shadow copy is still holding the "old" values, an attacker can exploit the old values. Then it becomes a race condition between the attacker and the update process of who can reach the target, shadow copy first, and, if the attacker reaches first, the attacker wins.</xhtml:li>
			    <xhtml:li>The attacker might send a "spoofed" update request to the target shadow copy, pretending that this update request is coming from the original copy.  This spoofed request might cause the targeted shadow copy to update its values to some attacker-friendly values, while the original copies remain unchanged by the attacker.</xhtml:li>
			    <xhtml:li>Suppose a situation where the original copy has a system of reverting back to its original value if it does not hear back from all the shadow copies that such copies have successfully completed the update request. In such a case, an attack might occur as follows: (1) the original copy might send an update request; (2) the shadow copy updates it; (3) the shadow copy sends back the successful completion message; (4) through a separate issue, the attacker is able to intercept the shadow copy's completion message. In this case, the original copy thinks that the update did not succeed, hence it reverts to its original value. Now there is a situation where the original copy has the "old" value, and the shadow copy has the "new" value.</xhtml:li>
			</xhtml:ul>
		     </xhtml:div>
		  </xhtml:div>
            </Extended_Description>
         <Related_Weaknesses>
            <Related_Weakness Nature="ChildOf" CWE_ID="1250" View_ID="1000" Ordinal="Primary"/>
         </Related_Weaknesses>
            <Applicable_Platforms>
                <Language Name="VHDL" Prevalence="Undetermined"/>
                <Language Name="Verilog" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
		<Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
		<Technology Name="Security IP" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Common_Consequences>
                <Consequence>
                    <Scope>Confidentiality</Scope>
                    <Scope>Integrity</Scope>
                    <Scope>Availability</Scope>
                    <Scope>Access Control</Scope>
                    <Scope>Accountability</Scope>
                    <Scope>Authentication</Scope>
                    <Scope>Authorization</Scope>
                    <Scope>Non-Repudiation</Scope>
                    <Impact>Varies by Context</Impact>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
              <Mitigation>
                <Phase>Architecture and Design</Phase>
                <Description>
                  <xhtml:p>Whenever there are multiple, physically different copies of the same value that might change and the process to update them is not instantaneous and atomic, it is impossible to assert that the original and shadow copies will always be in sync - there will always be a time period when they are out of sync. To mitigate the consequential risk, the recommendations essentially are:</xhtml:p>
                  <xhtml:div style="margin-left:10px;">
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                          <xhtml:li>Make this out-of-sync time period as small as possible, and</xhtml:li>
                          <xhtml:li>Make the update process as robust as possible.</xhtml:li>
			</xhtml:ul>
		     </xhtml:div>
		  </xhtml:div>
                </Description>
               <Effectiveness>Moderate</Effectiveness>
              </Mitigation>
            </Potential_Mitigations>
         <Demonstrative_Examples>
            <Demonstrative_Example Demonstrative_Example_ID="DX-132">
	       <Intro_Text>Suppose a processor's Memory Management Unit (MMU) has 5 other shadow MMUs to distribute its workload for its various cores. Each MMU has the start address and end address of "accessible" memory. Any time this accessible range changes (as per the processor's boot status), the main MMU sends an update message to all the shadow MMUs.</Intro_Text>
	       <Body_Text>Suppose the interconnect fabric does not prioritize such "update" packets over other general traffic packets. This introduces a race condition. If an attacker can flood the target with enough messages so that some of those attack packets reach the target before the new access ranges gets updated, then the attacker can leverage this scenario.</Body_Text>
            </Demonstrative_Example>
         </Demonstrative_Examples>
	      <Notes>
		<Note Type="Research Gap">
		    Issues related to state and cache - creation,
		    preservation, and update - are a significant gap in
		    CWE that is expected to be addressed in future
		    versions.  It likely has relationships to concurrency
		    and synchronization, incorrect behavior order, and
		    other areas that already have some coverage in CWE,
		    although the focus has typically been on independent
		    processes on the same operating system - not on
		    independent systems that are all a part of a larger
		    system-of-systems.
		  </Note>
		</Notes>
            <Content_History>
                <Submission>
                    <Submission_Name>Parbati Kumar Manna</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-02-10</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="1252" Name="CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations" Abstraction="Base" Structure="Simple" Status="Incomplete">
            <Description>The CPU is not configured to provide hardware support for exclusivity of write and execute operations on memory. This allows an attacker to execute data from all of memory.</Description>
            <Extended_Description>
                <xhtml:p>CPUs provide a special bit that supports exclusivity of write and execute operations. This bit is used to segregate areas of memory to either mark them as code (instructions, which can be executed) or data (which should not be executed). In this way, if a user can write to a region of memory, the user cannot execute from that region and vice versa. This exclusivity provided by special hardware bit is leveraged by the operating system to protect executable space. While this bit is available in most modern processors by default, in some CPUs the exclusivity is implemented via a memory-protection unit (MPU) and memory-management unit (MMU) in which memory regions can be carved out with exact read, write, and execute permissions. However, if the CPU does not have an MMU/MPU, then there is no write exclusivity. Without configuring exclusivity of operations via segregated areas of memory, an attacker may be able to inject malicious code onto memory and later execute it.</xhtml:p>
            </Extended_Description>
			<Related_Weaknesses>
              <Related_Weakness Nature="ChildOf" CWE_ID="284" View_ID="1000" Ordinal="Primary"/>
			</Related_Weaknesses>
            <Applicable_Platforms>
                <Language Class="Language-Independent" Prevalence="Undetermined"/>
                <Operating_System Class="OS-Independent" Prevalence="Undetermined"/>
                <Architecture Class="Architecture-Independent" Prevalence="Undetermined"/>
                <Technology Name="Microcontroller IP" Prevalence="Undetermined"/>
                <Technology Name="Processor IP" Prevalence="Undetermined"/>
            </Applicable_Platforms>
            <Modes_Of_Introduction>
                <Introduction>
					<Phase>Architecture and Design</Phase>
                </Introduction>
            </Modes_Of_Introduction>
            <Common_Consequences>
                <Consequence>
                    <Scope>Confidentiality</Scope>
                    <Scope>Integrity</Scope>
                    <Impact>Execute Unauthorized Code or Commands</Impact>
                </Consequence>
            </Common_Consequences>
            <Potential_Mitigations>
                <Mitigation>
                    <Phase>Architecture and Design</Phase>
                    <Description>
                        <xhtml:p>Implement a dedicated bit that can be leveraged by the Operating System to mark data areas as non-executable. If such a bit is not available in the CPU, implement MMU/MPU (memory management unit / memory protection unit).</xhtml:p>                     
                    </Description>
                </Mitigation>
                <Mitigation>
                    <Phase>Integration</Phase>
                    <Description>
                        <xhtml:p>If MMU/MPU are not available, then the firewalls need to be implemented in the SoC interconnect to mimic the write-exclusivity operation.</xhtml:p>                     
                    </Description>
                </Mitigation>
            </Potential_Mitigations>
            <Demonstrative_Examples>
                <Demonstrative_Example>
                    <Intro_Text>MCS51 Microcontroller (based on 8051) does not have a special bit to support write exclusivity. It also does not have an MMU/MPU support. The Cortex-M CPU has an optional MPU that supports up to 8 regions.</Intro_Text>
                    <Example_Code Nature="bad" Language="Other">
                        <xhtml:div>The optional MPU is not configured.</xhtml:div>
                    </Example_Code>
                    <Body_Text>If the MPU is not configured, then an attacker will be able to inject malicious data into memory and execute it.</Body_Text>
            	</Demonstrative_Example>
            </Demonstrative_Examples>
            <References>
                <Reference External_Reference_ID="REF-1076"/>
                <Reference External_Reference_ID="REF-1077"/>
                <Reference External_Reference_ID="REF-1078"/>
            </References>

            <Content_History>
                <Submission>
                    <Submission_Name>Arun Kanuparthi</Submission_Name>
                    <Submission_Organization>Intel Corporation</Submission_Organization>
                    <Submission_Date>2020-02-13</Submission_Date>
                </Submission>
            </Content_History>
        </Weakness>
      <Weakness ID="203" Name="Observable Discrepancy" Abstraction="Base" Structure="Simple" Status="Incomplete">
         <Description>The product behaves differently or sends different responses under different circumstances in a way that is observable to an unauthorized actor, which exposes security-relevant information about the state of the product, such as whether a particular operation was successful or not.</Description>
         <Extended_Description>Discrepancies can take many forms and include things like responses, timing, control flow, or general behavior. These discrepancies can reveal information about the product's operation or internal state to an unauthorized actor. In some cases, discrepancies can be used by attackers to form a side channel.</Extended_Description>
         <Related_Weaknesses>
            <Related_Weakness Nature="ChildOf" CWE_ID="200" View_ID="1000" Ordinal="Primary"/>
            <Related_Weakness Nature="ChildOf" CWE_ID="200" View_ID="1003" Ordinal="Primary"/>
         </Related_Weaknesses>
         <Applicable_Platforms>
            <Language Class="Language-Independent" Prevalence="Undetermined"/>
            <Technology Class="Technology-Independent" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Alternate_Terms>
            <Alternate_Term>
               <Term>Side Channel Attack</Term>
               <Description>Observable Discrepancies are at the root of class of attacks known as side channel attacks.</Description>
            </Alternate_Term>
         </Alternate_Terms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
            </Introduction>
            <Introduction>
               <Phase>Implementation</Phase>
            </Introduction>
         </Modes_Of_Introduction>
         <Common_Consequences>
            <Consequence>
               <Scope>Confidentiality</Scope>
               <Scope>Access Control</Scope>
               <Impact>Read Application Data</Impact>
               <Impact>Bypass Protection Mechanism</Impact>
               <Note>An attacker can gain access to sensitive information about the system, including authentication information that may allow an attacker to gain access to the system.</Note>
            </Consequence>
            <Consequence>
               <Scope>Confidentiality</Scope>
               <Impact>Read Application Data</Impact>
               <Note>Crypto primitives being vulnerable to side-channel-attacks could render the supposedly encrypted data unencrypted plaintext in the worst case. This would compromise any security property.</Note>
            </Consequence>
         </Common_Consequences>
         <Potential_Mitigations>
            <Mitigation Mitigation_ID="MIT-46">
               <Phase>Architecture and Design</Phase>
               <Strategy>Separation of Privilege</Strategy>
               <Description>
                  <xhtml:p>Compartmentalize the system to have "safe" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.</xhtml:p>
                  <xhtml:p>Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.</xhtml:p>
               </Description>
            </Mitigation>
            <Mitigation Mitigation_ID="MIT-39">
               <Phase>Implementation</Phase>
               <Description>
                  <xhtml:p>Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success.</xhtml:p>
                  <xhtml:p>If errors must be tracked in some detail, capture them in log messages - but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not.</xhtml:p>
               </Description>
            </Mitigation>
         </Potential_Mitigations>
         <Demonstrative_Examples>
            <Demonstrative_Example Demonstrative_Example_ID="DX-38">
               <Intro_Text>The following code checks validity of the supplied username and password and notifies the user of a successful or failed login.</Intro_Text>
               <Example_Code Nature="bad" Language="Perl">
                  <xhtml:div>my $username=param('username');<xhtml:br/>my $password=param('password');<xhtml:br/>
                     <xhtml:br/>if (IsValidUsername($username) == 1)<xhtml:br/>{<xhtml:div style="margin-left:10px;">if (IsValidPassword($username, $password) == 1)<xhtml:br/>{<xhtml:div style="margin-left:10px;">print "Login Successful";</xhtml:div>}<xhtml:br/>else<xhtml:br/>{<xhtml:div style="margin-left:10px;">print "Login Failed - incorrect password";</xhtml:div>}</xhtml:div>}<xhtml:br/>else<xhtml:br/>{<xhtml:div style="margin-left:10px;">print "Login Failed - unknown username";</xhtml:div>}</xhtml:div>
               </Example_Code>
               <Body_Text>In the above code, there are different messages for when an incorrect username is supplied, versus when the username is correct but the password is wrong. This difference enables a potential attacker to understand the state of the login function, and could allow an attacker to discover a valid username by trying different values until the incorrect password message is returned. In essence, this makes it easier for an attacker to obtain half of the necessary authentication credentials.</Body_Text>
               <Body_Text>While this type of information may be helpful to a user, it is also useful to a potential attacker. In the above example, the message for both failed cases should be the same, such as:</Body_Text>
               <Example_Code Nature="result">
                  <xhtml:div>"Login Failed - incorrect username or password"</xhtml:div>
               </Example_Code>
            </Demonstrative_Example>
            <Demonstrative_Example>
               <Intro_Text>Non-uniform processing time causes timing channel.</Intro_Text>
               <Example_Code Nature="bad">Suppose a hardware IP for implementing an encryption routine works fine per se, but the time taken to output the result of the encryption routine depends on a certain relationship between the input plaintext and the key (e.g., suppose, if the plaintext is similar to the key, it would run very fast).</Example_Code>
               <Body_Text>In the example above, an attacker can vary the inputs and, depending on the seen differences between processing times (different plaintexts take different time), can infer certain information about the key.</Body_Text>
               <Example_Code Nature="good">If the actual processing time was different for different plaintexts, artificial delays can be introduced to ensured all plaintexts take equal time to execute, even though the timing was internally different.</Example_Code>
            </Demonstrative_Example>
         </Demonstrative_Examples>
         <Observed_Examples>
            <Observed_Example>
               <Reference>CVE-2002-2094</Reference>
               <Description>This, and others, use ".." attacks and monitor error responses, so there is overlap with directory traversal.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-2094</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2001-1483</Reference>
               <Description>Enumeration of valid usernames based on inconsistent responses</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1483</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2001-1528</Reference>
               <Description>Account number enumeration via inconsistent responses.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1528</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2004-2150</Reference>
               <Description>User enumeration via discrepancies in error messages.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-2150</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2005-1650</Reference>
               <Description>User enumeration via discrepancies in error messages.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1650</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2004-0294</Reference>
               <Description>Bulletin Board displays different error messages when a user exists or not, which makes it easier for remote attackers to identify valid users and conduct a brute force password guessing attack.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0294</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2004-0243</Reference>
               <Description>Operating System, when direct remote login is disabled, displays a different message if the password is correct, which allows remote attackers to guess the password via brute force methods.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0243</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2002-0514</Reference>
               <Description>Product allows remote attackers to determine if a port is being filtered because the response packet TTL is different than the default TTL.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0514</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2002-0515</Reference>
               <Description>Product sets a different TTL when a port is being filtered than when it is not being filtered, which allows remote attackers to identify filtered ports by comparing TTLs.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0515</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2002-0208</Reference>
               <Description>Product modifies TCP/IP stack and ICMP error messages in unusual ways that show the product is in use.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0208</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2004-2252</Reference>
               <Description>Behavioral infoleak by responding to SYN-FIN packets.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-2252</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2001-1387</Reference>
               <Description>Product may generate different responses than specified by the administrator, possibly leading to an information leak.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1387</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2004-0778</Reference>
               <Description>Version control system allows remote attackers to determine the existence of arbitrary files and directories via the -X command for an alternate history file, which causes different error messages to be returned.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0778</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2004-1428</Reference>
               <Description>FTP server generates an error message if the user name does not exist instead of prompting for a password, which allows remote attackers to determine valid usernames.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1428</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2003-0078</Reference>
               <Description>SSL implementation does not perform a MAC computation if an incorrect block cipher padding is used, which causes an information leak (timing discrepancy) that may make it easier to launch cryptographic attacks that rely on distinguishing between padding and MAC verification errors, possibly leading to extraction of the original plaintext, aka the "Vaudenay timing attack."</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0078</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2000-1117</Reference>
               <Description>Virtual machine allows malicious web site operators to determine the existence of files on the client by measuring delays in the execution of the getSystemResource method.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-1117</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2003-0637</Reference>
               <Description>Product uses a shorter timeout for a non-existent user than a valid user, which makes it easier for remote attackers to guess usernames and conduct brute force password guessing.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0637</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2003-0190</Reference>
               <Description>Product immediately sends an error message when a user does not exist, which allows remote attackers to determine valid usernames via a timing attack.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0190</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2004-1602</Reference>
               <Description>FTP server responds in a different amount of time when a given username exists, which allows remote attackers to identify valid usernames by timing the server response.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1602</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2005-0918</Reference>
               <Description>Browser allows remote attackers to determine the existence of arbitrary files by setting the src property to the target filename and using Javascript to determine if the web page immediately stops loading, which indicates whether the file exists or not.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0918</Link>
            </Observed_Example>
         </Observed_Examples>
         <Taxonomy_Mappings>
            <Taxonomy_Mapping Taxonomy_Name="PLOVER">
               <Entry_Name>Discrepancy Information Leaks</Entry_Name>
            </Taxonomy_Mapping>
            <Taxonomy_Mapping Taxonomy_Name="OWASP Top Ten 2007">
               <Entry_ID>A6</Entry_ID>
               <Entry_Name>Information Leakage and Improper Error Handling</Entry_Name>
               <Mapping_Fit>CWE More Specific</Mapping_Fit>
            </Taxonomy_Mapping>
            <Taxonomy_Mapping Taxonomy_Name="OWASP Top Ten 2004">
               <Entry_ID>A7</Entry_ID>
               <Entry_Name>Improper Error Handling</Entry_Name>
               <Mapping_Fit>CWE More Specific</Mapping_Fit>
            </Taxonomy_Mapping>
         </Taxonomy_Mappings>
         <Content_History>
            <Submission>
               <Submission_Name>PLOVER</Submission_Name>
            </Submission>
            <Modification>
               <Modification_Name>Eric Dalci</Modification_Name>
               <Modification_Organization>Cigital</Modification_Organization>
               <Modification_Date>2008-07-01</Modification_Date>
               <Modification_Comment>updated Potential_Mitigations, Time_of_Introduction</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2008-09-08</Modification_Date>
               <Modification_Comment>updated Relationships, Taxonomy_Mappings</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2009-12-28</Modification_Date>
               <Modification_Comment>updated Description, Name</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2011-06-01</Modification_Date>
               <Modification_Comment>updated Common_Consequences</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2012-05-11</Modification_Date>
               <Modification_Comment>updated Common_Consequences, Demonstrative_Examples, Observed_Examples, Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2012-10-30</Modification_Date>
               <Modification_Comment>updated Potential_Mitigations</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2014-07-30</Modification_Date>
               <Modification_Comment>updated Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2017-11-08</Modification_Date>
               <Modification_Comment>updated Applicable_Platforms</Modification_Comment>
            </Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2019-06-20</Modification_Date>
					<Modification_Comment>updated Relationships, Type</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-02-24</Modification_Date>
					<Modification_Comment>updated Alternate_Terms, Applicable_Platforms, Common_Consequences, Demonstrative_Examples, Description, Name, Observed_Examples, Relationships</Modification_Comment>
				</Modification>
            <Previous_Entry_Name Date="2009-12-28">Discrepancy Information Leaks</Previous_Entry_Name>
			<Previous_Entry_Name Date="2020-02-24">Information Exposure Through Discrepancy</Previous_Entry_Name>
         </Content_History>
      </Weakness>
      <Weakness ID="226" Name="Sensitive Information Uncleared in Resource Before Release for Reuse" Abstraction="Base" Structure="Simple" Status="Draft">
         <Description>The product prepares to release a resource such as memory or a file so that the resource can be reused by other entities, but the product does not fully clear previously-used sensitive information from that resource before the resource is released.</Description>
         <Extended_Description>
			 <xhtml:p>When resources are released, they can be made available to other parties for reuse.  For example, after memory is used and released, an operating system may make the memory available to another process, or disk space may be reallocated when a file is deleted.  It is not necessarily guaranteed that the operating system will re-initialize the resource or otherwise remove the original contents.</xhtml:p>
			 <xhtml:p>Even when the resource is reused by the same process, this weakness can arise when new data is not as large as the old data, which leaves portions of the old data still available. Equivalent errors can occur in other situations where the length of data is variable but the associated data structure is not. If memory is not cleared after use, it may allow unintended actors to read the data when the memory is reallocated.</xhtml:p>
         </Extended_Description>
         <Related_Weaknesses>
            <Related_Weakness Nature="ChildOf" CWE_ID="459" View_ID="1000" Ordinal="Primary"/>
            <Related_Weakness Nature="ChildOf" CWE_ID="212" View_ID="1000"/>
            <Related_Weakness Nature="CanPrecede" CWE_ID="201" View_ID="1000"/>
         </Related_Weaknesses>
         <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
         </Weakness_Ordinalities>
         <Applicable_Platforms>
            <Language Class="Language-Independent" Prevalence="Undetermined"/>
            <Technology Class="Technology-Independent" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
            </Introduction>
            <Introduction>
               <Phase>Implementation</Phase>
            </Introduction>
         </Modes_Of_Introduction>
         <Common_Consequences>
            <Consequence>
               <Scope>Confidentiality</Scope>
               <Impact>Read Application Data</Impact>
            </Consequence>
         </Common_Consequences>
         <Observed_Examples>
            <Observed_Example>
               <Reference>CVE-2003-0001</Reference>
               <Description>Ethernet NIC drivers do not pad frames with null bytes, leading to infoleak from malformed packets.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0001</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2003-0291</Reference>
               <Description>router does not clear information from DHCP packets that have been previously used</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0291</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2005-1406</Reference>
               <Description>Products do not fully clear memory buffers when less data is stored into the buffer than previous.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1406</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2005-1858</Reference>
               <Description>Products do not fully clear memory buffers when less data is stored into the buffer than previous.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1858</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2005-3180</Reference>
               <Description>Products do not fully clear memory buffers when less data is stored into the buffer than previous.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3180</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2005-3276</Reference>
               <Description>Product does not clear a data structure before writing to part of it, yielding information leak of previously used memory.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3276</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2002-2077</Reference>
               <Description>Memory not properly cleared before reuse.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-2077</Link>
            </Observed_Example>
         </Observed_Examples>
         <Functional_Areas>
            <Functional_Area>Memory Management</Functional_Area>
            <Functional_Area>Networking</Functional_Area>
         </Functional_Areas>
         <Affected_Resources>
            <Affected_Resource>Memory</Affected_Resource>
         </Affected_Resources>
         <Taxonomy_Mappings>
            <Taxonomy_Mapping Taxonomy_Name="PLOVER">
               <Entry_Name>Sensitive Information Uncleared Before Use</Entry_Name>
            </Taxonomy_Mapping>
            <Taxonomy_Mapping Taxonomy_Name="CERT C Secure Coding">
               <Entry_ID>MEM03-C</Entry_ID>
               <Entry_Name>Clear sensitive information stored in reusable resources returned for reuse</Entry_Name>
            </Taxonomy_Mapping>
            <Taxonomy_Mapping Taxonomy_Name="Software Fault Patterns">
               <Entry_ID>SFP23</Entry_ID>
               <Entry_Name>Exposed Data</Entry_Name>
            </Taxonomy_Mapping>
         </Taxonomy_Mappings>
         <Notes>
            <Note Type="Relationship">There is a close association between CWE-226 and CWE-212. The difference is partially that of perspective. CWE-226 is geared towards the final stage of the resource lifecycle, in which the resource is deleted, eliminated, expired, or otherwise released for reuse. Technically, this involves a transfer to a different control sphere, in which the original contents of the resource are no longer relevant. CWE-212, however, is intended for sensitive data in resources that are intentionally shared with others, so they are still active. This distinction is useful from the perspective of the CWE research view (CWE-1000).</Note>
            <Note Type="Maintenance">This entry needs modification to clarify the differences with CWE-212. The description also combines two problems that are distinct from the CWE research perspective - the inadvertent transfer of information to another sphere, and improper initialization/shutdown. Some of the associated taxonomy mappings reflect these different uses.</Note>
            <Note Type="Research Gap">Currently frequently found for network packets, but it can also exist in local memory allocation, files, etc.</Note>
         </Notes>
         <Content_History>
            <Submission>
               <Submission_Name>PLOVER</Submission_Name>
            </Submission>
            <Modification>
               <Modification_Name>Eric Dalci</Modification_Name>
               <Modification_Organization>Cigital</Modification_Organization>
               <Modification_Date>2008-07-01</Modification_Date>
               <Modification_Comment>updated Time_of_Introduction</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2008-09-08</Modification_Date>
               <Modification_Comment>updated Relationships, Other_Notes, Relationship_Notes, Taxonomy_Mappings, Weakness_Ordinalities</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2008-10-14</Modification_Date>
               <Modification_Comment>updated Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2008-11-24</Modification_Date>
               <Modification_Comment>updated Relationships, Taxonomy_Mappings</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2009-03-10</Modification_Date>
               <Modification_Comment>updated Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2009-05-27</Modification_Date>
               <Modification_Comment>updated Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2009-10-29</Modification_Date>
               <Modification_Comment>updated Description, Other_Notes</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2010-02-16</Modification_Date>
               <Modification_Comment>updated Applicable_Platforms, Maintenance_Notes, Relationship_Notes</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2010-09-27</Modification_Date>
               <Modification_Comment>updated Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2010-12-13</Modification_Date>
               <Modification_Comment>updated Description</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2011-06-01</Modification_Date>
               <Modification_Comment>updated Common_Consequences, Relationships, Taxonomy_Mappings</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2011-09-13</Modification_Date>
               <Modification_Comment>updated Relationships, Taxonomy_Mappings</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2012-05-11</Modification_Date>
               <Modification_Comment>updated Relationships, Taxonomy_Mappings</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2014-07-30</Modification_Date>
               <Modification_Comment>updated Relationships, Taxonomy_Mappings</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2017-11-08</Modification_Date>
               <Modification_Comment>updated Causal_Nature, Functional_Areas, Relationships, Taxonomy_Mappings</Modification_Comment>
            </Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-02-24</Modification_Date>
					<Modification_Comment>updated Applicable_Platforms, Description, Name, Relationships, Time_of_Introduction, Weakness_Ordinalities</Modification_Comment>
				</Modification>
            <Previous_Entry_Name Date="2008-04-11">Sensitive Information Uncleared Before Use</Previous_Entry_Name>
			<Previous_Entry_Name Date="2020-02-24">Sensitive Information Uncleared Before Release</Previous_Entry_Name>
         </Content_History>
      </Weakness>
      <Weakness ID="276" Name="Incorrect Default Permissions" Abstraction="Base" Structure="Simple" Status="Draft">
         <Description>The product, upon installation, sets incorrect permissions for an object that exposes it to an unintended actor.</Description>
         <Related_Weaknesses>
            <Related_Weakness Nature="ChildOf" CWE_ID="732" View_ID="1000" Ordinal="Primary"/>
            <Related_Weakness Nature="ChildOf" CWE_ID="732" View_ID="1003" Ordinal="Primary"/>
         </Related_Weaknesses>
         <Weakness_Ordinalities>
            <Weakness_Ordinality>
               <Ordinality>Primary</Ordinality>
            </Weakness_Ordinality>
         </Weakness_Ordinalities>
         <Applicable_Platforms>
            <Language Class="Language-Independent" Prevalence="Undetermined"/>
            <Technology Class="Technology-Independent" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
            </Introduction>
            <Introduction>
               <Phase>Implementation</Phase>
               <Note>REALIZATION: This weakness is caused during implementation of an architectural security tactic.</Note>
            </Introduction>
            <Introduction>
               <Phase>Installation</Phase>
            </Introduction>
            <Introduction>
               <Phase>Operation</Phase>
            </Introduction>
         </Modes_Of_Introduction>
         <Likelihood_Of_Exploit>Medium</Likelihood_Of_Exploit>
         <Common_Consequences>
            <Consequence>
               <Scope>Confidentiality</Scope>
               <Scope>Integrity</Scope>
               <Impact>Read Application Data</Impact>
               <Impact>Modify Application Data</Impact>
            </Consequence>
         </Common_Consequences>
         <Detection_Methods>
            <Detection_Method>
               <Method>Automated Static Analysis - Binary or Bytecode</Method>
               <Description>
                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>
                  <xhtml:div style="margin-left:10px;">
                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                           <xhtml:li>Inter-application Flow Analysis</xhtml:li>
                        </xhtml:ul>
                     </xhtml:div>
                  </xhtml:div>
               </Description>
               <Effectiveness>SOAR Partial</Effectiveness>
            </Detection_Method>
            <Detection_Method>
               <Method>Manual Static Analysis - Binary or Bytecode</Method>
               <Description>
                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>
                  <xhtml:div style="margin-left:10px;">
                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                           <xhtml:li>Binary / Bytecode disassembler - then use manual analysis for vulnerabilities &amp; anomalies</xhtml:li>
                        </xhtml:ul>
                     </xhtml:div>
                  </xhtml:div>
               </Description>
               <Effectiveness>SOAR Partial</Effectiveness>
            </Detection_Method>
            <Detection_Method>
               <Method>Dynamic Analysis with Automated Results Interpretation</Method>
               <Description>
                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>
                  <xhtml:div style="margin-left:10px;">
                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                           <xhtml:li>Host-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria</xhtml:li>
                           <xhtml:li>Web Application Scanner</xhtml:li>
                           <xhtml:li>Web Services Scanner</xhtml:li>
                           <xhtml:li>Database Scanners</xhtml:li>
                        </xhtml:ul>
                     </xhtml:div>
                  </xhtml:div>
               </Description>
               <Effectiveness>SOAR Partial</Effectiveness>
            </Detection_Method>
            <Detection_Method>
               <Method>Dynamic Analysis with Manual Results Interpretation</Method>
               <Description>
                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>
                  <xhtml:div style="margin-left:10px;">
                     <xhtml:div>Highly cost effective:</xhtml:div>
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                           <xhtml:li>Host Application Interface Scanner</xhtml:li>
                        </xhtml:ul>
                     </xhtml:div>
                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                           <xhtml:li>Fuzz Tester</xhtml:li>
                           <xhtml:li>Framework-based Fuzzer</xhtml:li>
                           <xhtml:li>Automated Monitored Execution</xhtml:li>
                           <xhtml:li>Forced Path Execution</xhtml:li>
                        </xhtml:ul>
                     </xhtml:div>
                  </xhtml:div>
               </Description>
               <Effectiveness>High</Effectiveness>
            </Detection_Method>
            <Detection_Method>
               <Method>Manual Static Analysis - Source Code</Method>
               <Description>
                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>
                  <xhtml:div style="margin-left:10px;">
                     <xhtml:div>Highly cost effective:</xhtml:div>
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                           <xhtml:li>Manual Source Code Review (not inspections)</xhtml:li>
                        </xhtml:ul>
                     </xhtml:div>
                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                           <xhtml:li>Focused Manual Spotcheck - Focused manual analysis of source</xhtml:li>
                        </xhtml:ul>
                     </xhtml:div>
                  </xhtml:div>
               </Description>
               <Effectiveness>High</Effectiveness>
            </Detection_Method>
            <Detection_Method>
               <Method>Automated Static Analysis - Source Code</Method>
               <Description>
                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>
                  <xhtml:div style="margin-left:10px;">
                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                           <xhtml:li>Context-configured Source Code Weakness Analyzer</xhtml:li>
                        </xhtml:ul>
                     </xhtml:div>
                  </xhtml:div>
               </Description>
               <Effectiveness>SOAR Partial</Effectiveness>
            </Detection_Method>
            <Detection_Method>
               <Method>Automated Static Analysis</Method>
               <Description>
                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>
                  <xhtml:div style="margin-left:10px;">
                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                           <xhtml:li>Configuration Checker</xhtml:li>
                        </xhtml:ul>
                     </xhtml:div>
                  </xhtml:div>
               </Description>
               <Effectiveness>SOAR Partial</Effectiveness>
            </Detection_Method>
            <Detection_Method>
               <Method>Architecture or Design Review</Method>
               <Description>
                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>
                  <xhtml:div style="margin-left:10px;">
                     <xhtml:div>Highly cost effective:</xhtml:div>
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                           <xhtml:li>Formal Methods / Correct-By-Construction</xhtml:li>
                        </xhtml:ul>
                     </xhtml:div>
                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>
                     <xhtml:div style="margin-left:10px;">
                        <xhtml:ul>
                           <xhtml:li>Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)</xhtml:li>
                        </xhtml:ul>
                     </xhtml:div>
                  </xhtml:div>
               </Description>
               <Effectiveness>High</Effectiveness>
            </Detection_Method>
         </Detection_Methods>
         <Potential_Mitigations>
            <Mitigation Mitigation_ID="MIT-1">
               <Phase>Architecture and Design</Phase>
               <Phase>Operation</Phase>
               <Description>Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.</Description>
            </Mitigation>
            <Mitigation Mitigation_ID="MIT-46">
               <Phase>Architecture and Design</Phase>
               <Strategy>Separation of Privilege</Strategy>
               <Description>
                  <xhtml:p>Compartmentalize the system to have "safe" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.</xhtml:p>
                  <xhtml:p>Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.</xhtml:p>
               </Description>
            </Mitigation>
         </Potential_Mitigations>
         <Observed_Examples>
            <Observed_Example>
               <Reference>CVE-2005-1941</Reference>
               <Description>Executables installed world-writable.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1941</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2002-1713</Reference>
               <Description>Home directories installed world-readable.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1713</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2001-1550</Reference>
               <Description>World-writable log files allow information loss; world-readable file has cleartext passwords.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1550</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2002-1711</Reference>
               <Description>World-readable directory.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1711</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2002-1844</Reference>
               <Description>Windows product uses insecure permissions when installing on Solaris (genesis: port error).</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1844</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2001-0497</Reference>
               <Description>Insecure permissions for a shared secret key file. Overlaps cryptographic problem.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0497</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-1999-0426</Reference>
               <Description>Default permissions of a device allow IP spoofing.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-1999-0426</Link>
            </Observed_Example>
         </Observed_Examples>
         <Taxonomy_Mappings>
            <Taxonomy_Mapping Taxonomy_Name="PLOVER">
               <Entry_Name>Insecure Default Permissions</Entry_Name>
            </Taxonomy_Mapping>
            <Taxonomy_Mapping Taxonomy_Name="CERT C Secure Coding">
               <Entry_ID>FIO06-C</Entry_ID>
               <Entry_Name>Create files with appropriate access permissions</Entry_Name>
            </Taxonomy_Mapping>
            <Taxonomy_Mapping Taxonomy_Name="The CERT Oracle Secure Coding Standard for Java (2011)">
               <Entry_ID>FIO01-J</Entry_ID>
               <Entry_Name>Create files with appropriate access permission</Entry_Name>
            </Taxonomy_Mapping>
         </Taxonomy_Mappings>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="1"/>
            <Related_Attack_Pattern CAPEC_ID="127"/>
            <Related_Attack_Pattern CAPEC_ID="81"/>
         </Related_Attack_Patterns>
         <References>
            <Reference External_Reference_ID="REF-62" Section="Chapter 3, &#34;Insecure Defaults&#34;, Page 69"/>
         </References>
         <Content_History>
            <Submission>
               <Submission_Name>PLOVER</Submission_Name>
            </Submission>
            <Modification>
               <Modification_Name>Eric Dalci</Modification_Name>
               <Modification_Organization>Cigital</Modification_Organization>
               <Modification_Date>2008-07-01</Modification_Date>
               <Modification_Comment>updated Time_of_Introduction</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2008-09-08</Modification_Date>
               <Modification_Comment>updated Relationships, Taxonomy_Mappings, Weakness_Ordinalities</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2008-11-24</Modification_Date>
               <Modification_Comment>updated Relationships, Taxonomy_Mappings</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2009-05-27</Modification_Date>
               <Modification_Comment>updated Description, Name</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2011-06-01</Modification_Date>
               <Modification_Comment>updated Common_Consequences, Relationships, Taxonomy_Mappings</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2011-09-13</Modification_Date>
               <Modification_Comment>updated Relationships, Taxonomy_Mappings</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2012-05-11</Modification_Date>
               <Modification_Comment>updated References, Related_Attack_Patterns, Relationships, Taxonomy_Mappings</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2012-10-30</Modification_Date>
               <Modification_Comment>updated Potential_Mitigations</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2014-07-30</Modification_Date>
               <Modification_Comment>updated Detection_Factors, Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2017-05-03</Modification_Date>
               <Modification_Comment>updated Related_Attack_Patterns</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2017-11-08</Modification_Date>
               <Modification_Comment>updated Applicable_Platforms, Causal_Nature, Modes_of_Introduction, Relationships, Taxonomy_Mappings</Modification_Comment>
            </Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2019-01-03</Modification_Date>
					<Modification_Comment>updated Relationships, Taxonomy_Mappings</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2019-06-20</Modification_Date>
					<Modification_Comment>updated Relationships, Type</Modification_Comment>
				</Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-02-24</Modification_Date>
					<Modification_Comment>updated Applicable_Platforms, Description, Detection_Factors, Relationships</Modification_Comment>
				</Modification>
            <Previous_Entry_Name Date="2009-05-27">Insecure Default Permissions</Previous_Entry_Name>
         </Content_History>
      </Weakness>
      <Weakness ID="325" Name="Missing Required Cryptographic Step" Abstraction="Base" Structure="Simple" Status="Draft">
         <Description>The product does not implement a required step in a cryptographic algorithm, resulting in weaker encryption than advertised by that algorithm.</Description>
         <Extended_Description>Cryptographic implementations should precisely follow the algorithms that define them, otherwise encryption can be weaker than expected.</Extended_Description>
         <Related_Weaknesses>
            <Related_Weakness Nature="ChildOf" CWE_ID="573" View_ID="1000" Ordinal="Primary"/>
            <Related_Weakness Nature="PeerOf" CWE_ID="358" View_ID="1000"/>
         </Related_Weaknesses>
         <Applicable_Platforms>
            <Language Class="Language-Independent" Prevalence="Undetermined"/>
            <Technology Class="Technology-Independent" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Implementation</Phase>
               <Note>
                  <xhtml:p>REALIZATION: This weakness is caused during implementation of an architectural security tactic.</xhtml:p>
                  <xhtml:p>Developers sometimes omit certain "expensive" (resource-intensive) steps in order to improve performance, especially in devices with limited memory or CPU cycles. This could be done under a mistaken impression that the step is unnecessary for preserving security. Alternately, the developer might adopt a threat model that is inconsistent with that of its consumers by accepting a risk for which the remaining protection seems "good enough."</xhtml:p>
               </Note>
            </Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
            </Introduction>
            <Introduction>
               <Phase>Requirements</Phase>
               <Note>
                  <xhtml:p>This issue can be introduced when the requirements for the algorithm are not clearly stated.</xhtml:p>
               </Note>
            </Introduction>
         </Modes_Of_Introduction>
         <Common_Consequences>
            <Consequence>
               <Scope>Access Control</Scope>
               <Impact>Bypass Protection Mechanism</Impact>
               <Note>If the cryptographic algorithm is used for authentication and authorization, then an attacker could gain unauthorized access to the system.</Note>
            </Consequence>
            <Consequence>
               <Scope>Confidentiality</Scope>
               <Scope>Integrity</Scope>
               <Impact>Read Application Data</Impact>
               <Impact>Modify Application Data</Impact>
               <Note>Sensitive data may be compromised by the use of a broken or risky cryptographic algorithm.</Note>
            </Consequence>
            <Consequence>
               <Scope>Accountability</Scope>
               <Scope>Non-Repudiation</Scope>
               <Impact>Hide Activities</Impact>
               <Note>If the cryptographic algorithm is used to ensure the identity of the source of the data (such as digital signatures), then a broken algorithm will compromise this scheme and the source of the data cannot be proven.</Note>
            </Consequence>
         </Common_Consequences>
         <Observed_Examples>
            <Observed_Example>
               <Reference>CVE-2001-1585</Reference>
               <Description>Missing challenge-response step allows authentication bypass using public key.</Description>
               <Link>http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1585</Link>
            </Observed_Example>
         </Observed_Examples>
         <Functional_Areas>
            <Functional_Area>Cryptography</Functional_Area>
         </Functional_Areas>
         <Taxonomy_Mappings>
            <Taxonomy_Mapping Taxonomy_Name="PLOVER">
               <Entry_Name>Missing Required Cryptographic Step</Entry_Name>
            </Taxonomy_Mapping>
            <Taxonomy_Mapping Taxonomy_Name="OWASP Top Ten 2007">
               <Entry_ID>A8</Entry_ID>
               <Entry_Name>Insecure Cryptographic Storage</Entry_Name>
               <Mapping_Fit>CWE More Specific</Mapping_Fit>
            </Taxonomy_Mapping>
            <Taxonomy_Mapping Taxonomy_Name="OWASP Top Ten 2007">
               <Entry_ID>A9</Entry_ID>
               <Entry_Name>Insecure Communications</Entry_Name>
               <Mapping_Fit>CWE More Specific</Mapping_Fit>
            </Taxonomy_Mapping>
         </Taxonomy_Mappings>
         <Related_Attack_Patterns>
            <Related_Attack_Pattern CAPEC_ID="68"/>
         </Related_Attack_Patterns>
         <Notes>
            <Note Type="Relationship">Overlaps incomplete/missing security check.</Note>
            <Note Type="Relationship">Can be resultant.</Note>
         </Notes>
         <Content_History>
            <Submission>
               <Submission_Name>PLOVER</Submission_Name>
            </Submission>
            <Modification>
               <Modification_Name>Eric Dalci</Modification_Name>
               <Modification_Organization>Cigital</Modification_Organization>
               <Modification_Date>2008-07-01</Modification_Date>
               <Modification_Comment>updated Time_of_Introduction</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2008-09-08</Modification_Date>
               <Modification_Comment>updated Description, Functional_Areas, Modes_of_Introduction, Relationships, Observed_Example, Relationship_Notes, Taxonomy_Mappings</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2011-06-01</Modification_Date>
               <Modification_Comment>updated Common_Consequences</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2012-05-11</Modification_Date>
               <Modification_Comment>updated Common_Consequences, Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2014-06-23</Modification_Date>
               <Modification_Comment>updated Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2014-07-30</Modification_Date>
               <Modification_Comment>updated Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2017-11-08</Modification_Date>
               <Modification_Comment>updated Applicable_Platforms, Modes_of_Introduction, Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2018-03-27</Modification_Date>
               <Modification_Comment>updated Relationships</Modification_Comment>
            </Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-02-24</Modification_Date>
					<Modification_Comment>updated Applicable_Platforms, Description, Relationships</Modification_Comment>
				</Modification>
         </Content_History>
      </Weakness>
      <Weakness ID="440" Name="Expected Behavior Violation" Abstraction="Base" Structure="Simple" Status="Draft">
         <Description>A feature, API, or function being used by a product behaves differently than the product expects.</Description>
         <Related_Weaknesses>
            <Related_Weakness Nature="ChildOf" CWE_ID="684" View_ID="1000" Ordinal="Primary"/>
         </Related_Weaknesses>
         <Applicable_Platforms>
            <Language Class="Language-Independent" Prevalence="Undetermined"/>
         </Applicable_Platforms>
         <Modes_Of_Introduction>
            <Introduction>
               <Phase>Architecture and Design</Phase>
            </Introduction>
            <Introduction>
               <Phase>Implementation</Phase>
            </Introduction>
            <Introduction>
               <Phase>Operation</Phase>
            </Introduction>
         </Modes_Of_Introduction>
         <Common_Consequences>
            <Consequence>
               <Scope>Other</Scope>
               <Impact>Quality Degradation</Impact>
               <Impact>Varies by Context</Impact>
            </Consequence>
         </Common_Consequences>
         <Observed_Examples>
            <Observed_Example>
               <Reference>CVE-2003-0187</Reference>
               <Description>Inconsistency in support of linked lists causes program to use large timeouts on "undeserving" connections.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0187</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2003-0465</Reference>
               <Description>"strncpy" in Linux kernel acts different than libc on x86, leading to expected behavior difference - sort of a multiple interpretation error?</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0465</Link>
            </Observed_Example>
            <Observed_Example>
               <Reference>CVE-2005-3265</Reference>
               <Description>Buffer overflow in product stems to the use of a third party library function that is expected to have internal protection against overflows, but doesn't.</Description>
               <Link>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3265</Link>
            </Observed_Example>
         </Observed_Examples>
         <Taxonomy_Mappings>
            <Taxonomy_Mapping Taxonomy_Name="PLOVER">
               <Entry_Name>Expected behavior violation</Entry_Name>
            </Taxonomy_Mapping>
         </Taxonomy_Mappings>
         <Notes>
            <Note Type="Theoretical">The consistency dimension of validity is the most appropriate relevant property of an expected behavior violation. That is, the behavior of the application is not consistent with the expectations of the developer, leading to a violation of the validity property of the software.</Note>
         </Notes>
         <Content_History>
            <Submission>
               <Submission_Name>PLOVER</Submission_Name>
            </Submission>
            <Modification>
               <Modification_Name>Eric Dalci</Modification_Name>
               <Modification_Organization>Cigital</Modification_Organization>
               <Modification_Date>2008-07-01</Modification_Date>
               <Modification_Comment>updated Time_of_Introduction</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2008-09-08</Modification_Date>
               <Modification_Comment>updated Relationships, Other_Notes, Taxonomy_Mappings</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2009-10-29</Modification_Date>
               <Modification_Comment>updated Other_Notes, Relevant_Properties, Theoretical_Notes</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2011-06-01</Modification_Date>
               <Modification_Comment>updated Common_Consequences</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2011-06-27</Modification_Date>
               <Modification_Comment>updated Common_Consequences</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2012-05-11</Modification_Date>
               <Modification_Comment>updated Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2014-07-30</Modification_Date>
               <Modification_Comment>updated Relationships</Modification_Comment>
            </Modification>
            <Modification>
               <Modification_Name>CWE Content Team</Modification_Name>
               <Modification_Organization>MITRE</Modification_Organization>
               <Modification_Date>2017-11-08</Modification_Date>
               <Modification_Comment>updated Applicable_Platforms, Relevant_Properties</Modification_Comment>
            </Modification>
				<Modification>
					<Modification_Name>CWE Content Team</Modification_Name>
					<Modification_Organization>MITRE</Modification_Organization>
					<Modification_Date>2020-02-24</Modification_Date>
					<Modification_Comment>updated Relationships</Modification_Comment>
				</Modification>
         </Content_History>
      </Weakness>
   </Weaknesses>
   <Categories>
      <Category ID="1195" Name="Manufacturing and Life Cycle Management Concerns" Status="Draft">
         <Summary>Weaknesses in this category are root-caused to defects that arise in the semiconductor-manufacturing process or during the life cycle and supply chain.</Summary>
         <Relationships>
             <Has_Member CWE_ID="1248" View_ID="1194"/>
         </Relationships>
         <Content_History>
             <Submission>
			     <Submission_Name>CWE Content Team</Submission_Name>
			     <Submission_Organization>MITRE</Submission_Organization>
                 <Submission_Date>2019-12-27</Submission_Date>
             </Submission>
         </Content_History>
      </Category>
      <Category ID="1196" Name="Security Flow Issues" Status="Draft">
         <Summary>Weaknesses in this category are related to improper design of full-system security flows, including but not limited to secure boot, secure update, and hardware-device attestation.</Summary>
         <Relationships>
             <Has_Member CWE_ID="1190" View_ID="1194"/>
             <Has_Member CWE_ID="1193" View_ID="1194"/>
         </Relationships>
         <Content_History>
             <Submission>
			     <Submission_Name>CWE Content Team</Submission_Name>
			     <Submission_Organization>MITRE</Submission_Organization>
                 <Submission_Date>2019-12-27</Submission_Date>
             </Submission>
         </Content_History>
      </Category>
      <Category ID="1197" Name="Integration Issues" Status="Draft">
         <Summary>Weaknesses in this category are those that arise due to integration of multiple hardware Intellectual Property (IP) cores from third parties, or from the prior generation of products into a common System-on-Chip (SoC) or hardware platform.</Summary>
         <Content_History>
             <Submission>
			     <Submission_Name>CWE Content Team</Submission_Name>
			     <Submission_Organization>MITRE</Submission_Organization>
                 <Submission_Date>2019-12-27</Submission_Date>
             </Submission>
         </Content_History>
      </Category>
      <Category ID="1198" Name="Privilege Separation and Access Control Issues" Status="Draft">
         <Summary>Weaknesses in this category are related to features and mechanisms providing hardware-based isolation and access control (e.g., identity, policy, locking control) of sensitive shared hardware resources such as registers and fuses.</Summary>
         <Relationships>
            <Has_Member CWE_ID="276" View_ID="1194"/>
            <Has_Member CWE_ID="1189" View_ID="1194"/>
            <Has_Member CWE_ID="1192" View_ID="1194"/>
            <Has_Member CWE_ID="1220" View_ID="1194"/>
            <Has_Member CWE_ID="1242" View_ID="1194"/>
         </Relationships>
         <Content_History>
             <Submission>
			     <Submission_Name>CWE Content Team</Submission_Name>
			     <Submission_Organization>MITRE</Submission_Organization>
                 <Submission_Date>2019-12-27</Submission_Date>
             </Submission>
         </Content_History>
      </Category>
      <Category ID="1199" Name="General Circuit and Logic Design Concerns" Status="Draft">
         <Summary>Weaknesses in this category are related to hardware-circuit design and logic (e.g., CMOS transistors, finite state machines, and registers) as well as issues related to hardware description languages such as System Verilog and VHDL.</Summary>
         <Relationships>
            <Has_Member CWE_ID="1209" View_ID="1194"/>
            <Has_Member CWE_ID="1221" View_ID="1194"/>
            <Has_Member CWE_ID="1223" View_ID="1194"/>
            <Has_Member CWE_ID="1224" View_ID="1194"/>
            <Has_Member CWE_ID="1231" View_ID="1194"/>
            <Has_Member CWE_ID="1232" View_ID="1194"/>
            <Has_Member CWE_ID="1233" View_ID="1194"/>
            <Has_Member CWE_ID="1234" View_ID="1194"/>
            <Has_Member CWE_ID="1245" View_ID="1194"/>
         </Relationships>
         <Content_History>
             <Submission>
			     <Submission_Name>CWE Content Team</Submission_Name>
			     <Submission_Organization>MITRE</Submission_Organization>
                 <Submission_Date>2019-12-27</Submission_Date>
             </Submission>
         </Content_History>
      </Category>
      <Category ID="1201" Name="Core and Compute Issues" Status="Draft">
         <Summary>Weaknesses in this category are typically associated with CPUs, Graphics, Vision, AI, FPGA, and microcontrollers.</Summary>
         <Relationships>
             <Has_Member CWE_ID="1252" View_ID="1194"/>
         </Relationships>
         <Content_History>
             <Submission>
			     <Submission_Name>CWE Content Team</Submission_Name>
			     <Submission_Organization>MITRE</Submission_Organization>
                 <Submission_Date>2019-12-27</Submission_Date>
             </Submission>
         </Content_History>
      </Category>
      <Category ID="1202" Name="Memory and Storage Issues" Status="Draft">
         <Summary>Weaknesses in this category are typically associated with memory (e.g., DRAM, SRAM) and storage technologies (e.g., NAND Flash, OTP, EEPROM, and eMMC).</Summary>
         <Relationships>
            <Has_Member CWE_ID="226" View_ID="1194"/>
            <Has_Member CWE_ID="1246" View_ID="1194"/>
            <Has_Member CWE_ID="1251" View_ID="1194"/>
         </Relationships>
         <Content_History>
             <Submission>
			     <Submission_Name>CWE Content Team</Submission_Name>
			     <Submission_Organization>MITRE</Submission_Organization>
                 <Submission_Date>2019-12-27</Submission_Date>
             </Submission>
         </Content_History>
      </Category>
      <Category ID="1203" Name="Peripherals, On-chip Fabric, and Interface/IO Problems" Status="Draft">
         <Summary>
		   Weaknesses in this category are related to hardware
		   security problems that apply to peripheral devices, IO
		   interfaces, on-chip interconnects, network-on-chip (NoC),
		   and buses.  For example, this category includes issues
		   related to design of hardware interconnect and/or protocols
		   such as PCIe, USB, SMBUS, general-purpose IO pins, and
		   user-input peripherals such as mouse and keyboard.
		 </Summary>
         <Content_History>
             <Submission>
			     <Submission_Name>CWE Content Team</Submission_Name>
			     <Submission_Organization>MITRE</Submission_Organization>
                 <Submission_Date>2019-12-27</Submission_Date>
             </Submission>
         </Content_History>
      </Category>
      <Category ID="1205" Name="Security Primitives and Cryptography Issues" Status="Draft">
         <Summary>Weaknesses in this category are related to hardware implementations of cryptographic protocols and other hardware-security primitives such as physical unclonable functions (PUFs) and random number generators (RNGs).</Summary>
         <Relationships>
            <Has_Member CWE_ID="203" View_ID="1194"/>
            <Has_Member CWE_ID="325" View_ID="1194"/>
            <Has_Member CWE_ID="1240" View_ID="1194"/>
            <Has_Member CWE_ID="1241" View_ID="1194"/>
         </Relationships>
         <Content_History>
             <Submission>
			     <Submission_Name>CWE Content Team</Submission_Name>
			     <Submission_Organization>MITRE</Submission_Organization>
                 <Submission_Date>2019-12-27</Submission_Date>
             </Submission>
         </Content_History>
      </Category>
      <Category ID="1206" Name="Power, Clock, and Reset Concerns" Status="Draft">
         <Summary>Weaknesses in this category are related to system power, voltage, current, temperature, clocks, system state saving/restoring, and resets at the platform and SoC level.</Summary>
         <Relationships>
             <Has_Member CWE_ID="1232" View_ID="1194"/>
             <Has_Member CWE_ID="1247" View_ID="1194"/>
         </Relationships>
         <Content_History>
             <Submission>
			     <Submission_Name>CWE Content Team</Submission_Name>
			     <Submission_Organization>MITRE</Submission_Organization>
                 <Submission_Date>2019-12-27</Submission_Date>
             </Submission>
         </Content_History>
      </Category>
      <Category ID="1207" Name="Debug and Test Problems" Status="Draft">
         <Summary>Weaknesses in this category are related to hardware debug and test interfaces such as JTAG and scan chain.</Summary>
         <Relationships>
             <Has_Member CWE_ID="1191" View_ID="1194"/>
             <Has_Member CWE_ID="1234" View_ID="1194"/>
             <Has_Member CWE_ID="1243" View_ID="1194"/>
             <Has_Member CWE_ID="1244" View_ID="1194"/>
         </Relationships>
         <Content_History>
             <Submission>
			     <Submission_Name>CWE Content Team</Submission_Name>
			     <Submission_Organization>MITRE</Submission_Organization>
                 <Submission_Date>2019-12-27</Submission_Date>
             </Submission>
         </Content_History>
      </Category>
      <Category ID="1208" Name="Cross-Cutting Problems" Status="Draft">
         <Summary>Weaknesses in this category can arise in multiple areas of hardware design or can apply to a wide cross-section of components.</Summary>
         <Relationships>
            <Has_Member CWE_ID="440" View_ID="1194"/>
            <Has_Member CWE_ID="1053" View_ID="1194"/>
         </Relationships>
         <Content_History>
             <Submission>
			     <Submission_Name>CWE Content Team</Submission_Name>
			     <Submission_Organization>MITRE</Submission_Organization>
                 <Submission_Date>2019-12-27</Submission_Date>
             </Submission>
         </Content_History>
      </Category>
   </Categories>
   <Views>
      <View ID="1194" Name="Hardware Design" Type="Graph" Status="Incomplete">
         <Objective>This view organizes weaknesses around concepts that are frequently used or encountered in hardware design. Accordingly, this view can align closely with the perspectives of designers, manufacturers, educators, and assessment vendors. It provides a variety of categories that are intended to simplify navigation, browsing, and mapping.</Objective>
         <Audience>
            <Stakeholder>
               <Type>Hardware Designers</Type>
               <Description>Hardware Designers use this view to better understand potential mistakes that can be made in specific areas of their IP design. The use of concepts with which hardware designers are familiar makes it easier to navigate.</Description>
            </Stakeholder>
            <Stakeholder>
               <Type>Educators</Type>
               <Description>Educators use this view to teach future professionals about the types of mistakes that are commonly made in hardware design.</Description>
            </Stakeholder>
         </Audience>
         <Members>
            <Has_Member CWE_ID="1195" View_ID="1194"/>
            <Has_Member CWE_ID="1196" View_ID="1194"/>
            <Has_Member CWE_ID="1197" View_ID="1194"/>
            <Has_Member CWE_ID="1198" View_ID="1194"/>
            <Has_Member CWE_ID="1199" View_ID="1194"/>
            <Has_Member CWE_ID="1201" View_ID="1194"/>
            <Has_Member CWE_ID="1202" View_ID="1194"/>
            <Has_Member CWE_ID="1203" View_ID="1194"/>
            <Has_Member CWE_ID="1205" View_ID="1194"/>
            <Has_Member CWE_ID="1206" View_ID="1194"/>
            <Has_Member CWE_ID="1207" View_ID="1194"/>
            <Has_Member CWE_ID="1208" View_ID="1194"/>
         </Members>
         <Notes>
            <Note Type="Other">The top level categories in this view represent commonly understood areas/terms within hardware design, and are meant to aid the user in identifying potential related weaknesses. It is possible for the same weakness to exist within multiple different categories.</Note>
            <Note Type="Other">This view attempts to present weaknesses in a simple and intuitive way. As such it targets a single level of abstraction. It is important to realize that not every CWE will be represented in this view. High-level class weaknesses and low-level variant weaknesses are mostly ignored. However, by exploring the weaknesses that are included, and following the defined relationships, one can find these higher and lower level weaknesses.</Note>
         </Notes>
         <Content_History>
            <Submission>
               <Submission_Name>CWE Content Team</Submission_Name>
               <Submission_Organization>MITRE</Submission_Organization>
               <Submission_Date>2019-12-27</Submission_Date>
            </Submission>
         </Content_History>
      </View>
   </Views>
   <External_References>
      <External_Reference Reference_ID="REF-1036">
		  <Author>Ali Abbasi and Majid Hashemi</Author>
		  <Title>Ghost in the PLC Designing an Undetectable Programmable Logic Controller Rootkit via Pin Control Attack</Title>
		  <Publication_Year>2016</Publication_Year>
		  <URL>https://www.blackhat.com/docs/eu-16/materials/eu-16-Abbasi-Ghost-In-The-PLC-Designing-An-Undetectable-Programmable-Logic-Controller-Rootkit-wp.pdf</URL>
	   </External_Reference>
      <External_Reference Reference_ID="REF-1037">
		  <Author>Kurt Rosenfeld</Author>
		  <Author>Ramesh Karri</Author>
		  <Title>Attacks and Defenses for JTAG</Title>
		  <Publication_Year>2010</Publication_Year>
		  <Publication_Month>--02</Publication_Month>
		  <URL>https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5406671</URL>
	   </External_Reference>
      <External_Reference Reference_ID="REF-1038">
		  <Title>DMA attack</Title>
		  <Publication_Year>2019</Publication_Year>
		  <Publication_Month>--10</Publication_Month>
		  <Publication_Day>---19</Publication_Day>
		  <URL>https://en.wikipedia.org/wiki/DMA_attack</URL>
	   </External_Reference>
      <External_Reference Reference_ID="REF-1039">
		  <Author>A. Theodore Markettos</Author>
		  <Author>Colin Rothwell</Author>
		  <Author>Brett F. Gutstein</Author>
		  <Author>Allison Pearce</Author>
		  <Author>Peter G. Neumann</Author>
		  <Author>Simon W. Moore</Author>
		  <Author>Robert N. M. Watson</Author>
		  <Title>Thunderclap: Exploring Vulnerabilities in Operating System IOMMU Protection via DMA from Untrustworthy Peripherals</Title>
		  <Publication_Year>2019</Publication_Year>
		  <Publication_Month>--02</Publication_Month>
		  <Publication_Day>---25</Publication_Day>
		  <URL>https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_05A-1_Markettos_paper.pdf</URL>
	   </External_Reference>
      <External_Reference Reference_ID="REF-1040">
		  <Author>Maximillian Dornseif</Author>
      <Author>Michael Becher</Author>
      <Author>Christian N. Klein</Author>
		  <Title>FireWire all your memory are belong to us</Title>
		  <Publication_Year>2005</Publication_Year>
		  <URL>https://cansecwest.com/core05/2005-firewire-cansecwest.pdf</URL>
	   </External_Reference>
      <External_Reference Reference_ID="REF-1041">
		  <Author>Rory Breuk</Author>
		  <Author>Albert Spruyt</Author>
		  <Author>Adam Boileau</Author>
		  <Title>Integrating DMA attacks in exploitation frameworks</Title>
		  <Publication_Year>2012</Publication_Year>
		  <Publication_Month>--02</Publication_Month>
		  <Publication_Day>---20</Publication_Day>
		  <URL>https://www.os3.nl/_media/2011-2012/courses/rp1/p14_report.pdf</URL>
	   </External_Reference>
      <External_Reference Reference_ID="REF-1042">
		  <Author>Maximillian Dornseif</Author>
		  <Title>Owned by an iPod</Title>
		  <Publication_Year>2004</Publication_Year>
		  <URL>https://pacsec.jp/psj04/psj04-dornseif-e.ppt</URL>
	   </External_Reference>
      <External_Reference Reference_ID="REF-1043">
		  <Author>Gopal Vishwakarma</Author>
		  <Author>Wonjun Lee</Author>
		  <Title>Exploiting JTAG and Its Mitigation in IOT: A Survey</Title>
		  <Publication_Year>2018</Publication_Year>
		  <Publication_Month>--12</Publication_Month>
		  <Publication_Day>---03</Publication_Day>
		  <URL>https://www.mdpi.com/1999-5903/10/12/121/pdf</URL>
	   </External_Reference>
      <External_Reference Reference_ID="REF-1044">
		  <Author>Dmytro Oleksiuk</Author>
		  <Title>My aimful life</Title>
		  <Publication_Year>2015</Publication_Year>
		  <Publication_Month>--09</Publication_Month>
		  <Publication_Day>---12</Publication_Day>
		  <URL>http://blog.cr4.sh/2015/09/breaking-uefi-security-with-software.html</URL>
	   </External_Reference>
      <External_Reference Reference_ID="REF-1046">
		  <Author>A. Theodore Markettos</Author>
		  <Author>Adam Boileau</Author>
		  <Title>Hit by a Bus:Physical Access Attacks with Firewire</Title>
		  <Publication_Year>2006</Publication_Year>
		  <URL>https://security-assessment.com/files/presentations/ab_firewire_rux2k6-final.pdf</URL>
	   </External_Reference>
      <External_Reference Reference_ID="REF-1056">
	        <Author>F-Secure Labs</Author>
	        <Title>Multiple Vulnerabilities in Barco Clickshare: JTAG access is not permanently disabled</Title>
	        <URL>https://labs.f-secure.com/advisories/multiple-vulnerabilities-in-barco-clickshare/</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1057">
	        <Author>Kurt Rosenfeld</Author>
	        <Author>Ramesh Karri</Author>
	        <Title>Attacks and Defenses for JTAG</Title>
	        <URL>https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5406671</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1058">
	        <Author>Moinuddin Qureshi</Author>
	        <Author>Michele Franchescini</Author>
			<Author>Vijayalakshmi Srinivasan</Author>
			<Author>Luis Lastras</Author>
			<Author>Bulent Abali</Author>
			<Author>John Karidis</Author>
	        <Title>Enhancing Lifetime and Security of PCM-Based Main Memory with Start-Gap Wear Leveling</Title>
	        <URL>https://researcher.watson.ibm.com/researcher/files/us-moinqureshi/papers-sgap.pdf</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1059">
	        <Author>Micron</Author>
	        <Title>Bad Block Management in NAND Flash Memory</Title>
	        <URL>https://www.micron.com/-/media/client/global/documents/products/technical-note/nand-flash/tn2959_bbm_in_nand_flash.pdf</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1060">
	        <Author>Farimah Farahmandi</Author>
	        <Author>Prabhat Mishra</Author>
	        <Title>FSM Anomaly Detection using Formal Analysis</Title>
	        <URL>https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8119228&amp;tag=1</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1061">
	        <Author>Keith Bowman</Author>
	        <Author>James Tschanz</Author>
	        <Author>Chris Wilkerson</Author>
	        <Author>Shih-Lien Lu</Author>
	        <Author>Tanay Karnik</Author>
	        <Author>Vivek De</Author>
	        <Author>Shekhar Borkar</Author>
	        <Title>Circuit Techniques for Dynamic Variation Tolerance</Title>
	        <URL>https://dl.acm.org/doi/10.1145/1629911.1629915</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1062">
	        <Author>Dan Ernst</Author>
	        <Author>Nam Sung Kim</Author>
	        <Author>Shidhartha Das</Author>
	        <Author>Sanjay Pant</Author>
	        <Author>Rajeev Rao</Author>
	        <Author>Toan Pham</Author>
	        <Author>Conrad Ziesler</Author>
	        <Author>David Blaauw</Author>
	        <Author>Todd Austin</Author>
	        <Author>Krisztian Flautner</Author>
	        <Author>Trevor Mudge</Author>
	        <Title>Razor: A Low-Power Pipeline Based on Circuit-Level Timing Speculation</Title>
	        <URL>https://web.eecs.umich.edu/~taustin/papers/MICRO36-Razor.pdf</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1063">
            <Author>James Tschanz</Author>
            <Author>Keith Bowman</Author>
            <Author>Steve Walstra</Author>
            <Author>Marty Agostinelli</Author>
            <Author>Tanay Karnik</Author>
            <Author>Vivek De</Author>
            <Title>Tunable Replica Circuits and Adaptive Voltage-Frequency Techniques for Dynamic Voltage, Temperature, and Aging Variation Tolerance</Title>
            <URL>https://ieeexplore.ieee.org/document/5205410</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1064">
	        <Author>Bilgiday Yuce</Author>
	        <Author>Nahid F. Ghalaty</Author>
	        <Author>Chinmay Deshpande</Author>
	        <Author>Conor Patrick</Author>
	        <Author>Leyla Nazhandali</Author>
	        <Author>Patrick Schaumont</Author>
	        <Title>FAME: Fault-attack Aware Microprocessor Extensions for Hardware Fault Detection and Software Fault Response</Title>
	        <URL>https://dl.acm.org/doi/10.1145/2948618.2948626</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1065">
	        <Author>Keith A. Bowman</Author>
	        <Author>James W. Tschanz</Author>
	        <Author>Shih-Lien L. Lu</Author>
	        <Author>Paolo A. Aseron</Author>
	        <Author>Muhammad M. Khellah</Author>
	        <Author>Arijit Raychowdhury</Author>
	        <Author>Bibiche M. Geuskens</Author>
	        <Author>Carlos Tokunaga</Author>
	        <Author>Chris B. Wilkerson</Author>
	        <Author>Tanay Karnik</Author>
	        <Author>Vivek De</Author>
	        <Title>A 45 nm Resilient Microprocessor Core for Dynamic Variation Tolerance</Title>
	        <URL>https://ieeexplore.ieee.org/document/5654663</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1066">
	        <Author>Niek Timmers</Author>
	        <Author>Albert Spruyt</Author>
	        <Title>Bypassing Secure Boot Using Fault Injection</Title>
	        <URL>https://www.blackhat.com/docs/eu-16/materials/eu-16-Timmers-Bypassing-Secure-Boot-Using-Fault-Injection.pdf</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1067">
	        <Author>Brian Bailey</Author>
	        <Title>Why Chips Die</Title>
	        <URL>https://semiengineering.com/why-chips-die/</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1068">
	        <Author>V. Lakshminarayan</Author>
	        <Title>What causes semiconductor devices to fail</Title>
	        <URL>https://www.edn.com/what-causes-semiconductor-devices-to-fail/</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1071">
	        <Author>Ali Abbasi</Author>
	        <Author>Tobias Scharnowski</Author>
	        <Author>Thorsten Holz</Author>
	        <Title>Doors of Durin: The Veiled Gate to Siemens S7 Silicon</Title>
	        <URL>https://i.blackhat.com/eu-19/Wednesday/eu-19-Abbasi-Doors-Of-Durin-The-Veiled-Gate-To-Siemens-S7-Silicon.pdf</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1072">
	        <Author>Sergei Skorobogatov</Author>
	        <Author>Christopher Woods</Author>
	        <Title>Breakthrough Silicon Scanning Discovers Backdoor in Military Chip</Title>
	        <URL>https://www.cl.cam.ac.uk/~sps32/Silicon_scan_draft.pdf</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1073">
	        <Author>Chris Domas</Author>
	        <Title>God Mode Unlocked: Hardware Backdoors in x86 CPUs</Title>
	        <URL>https://i.blackhat.com/us-18/Thu-August-9/us-18-Domas-God-Mode-Unlocked-Hardware-Backdoors-In-x86-CPUs.pdf</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1074">
	        <Author>Jonathan Brossard</Author>
	        <Title>Hardware Backdooring is Practical</Title>
	        <URL>https://media.blackhat.com/bh-us-12/Briefings/Brossard/BH_US_12_Brossard_Backdoor_Hacking_Slides.pdf</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1075">
	        <Author>Sergei Skorabogatov</Author>
	        <Title>Security, Reliability, and Backdoors</Title>
	        <URL>https://www.cl.cam.ac.uk/~sps32/SG_talk_SRB.pdf</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1076">
	        <Author>ARM</Author>
	        <Title>Cortex-R4 Manual</Title>
	        <URL>https://developer.arm.com/ip-products/processors/cortex-m/cortex-m4</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1077">
	        <Author>Intel</Author>
	        <Title>MCS 51 Microcontroller Family User's Manual</Title>
	        <URL>http://web.mit.edu/6.115/www/document/8051.pdf</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-1078">
	        <Author>ARM</Author>
	        <Title>Memory Protection Unit (MPU)</Title>
	        <URL>https://static.docs.arm.com/100699/0100/armv8m_architecture_memory_protection_unit_100699_0100_00_en.pdf</URL>
	    </External_Reference>
      <External_Reference Reference_ID="REF-62">
		  <Author>Mark Dowd</Author>
		  <Author>John McDonald</Author>
		  <Author>Justin Schuh</Author>
		  <Title>The Art of Software Security Assessment</Title>
		  <Edition>1st Edition</Edition>
		  <Publication_Year>2006</Publication_Year>
		  <Publisher>Addison Wesley</Publisher>
	   </External_Reference>
      <External_Reference Reference_ID="REF-963">
			<Author>Robert A. Martin</Author>
			<Author>Lawrence H. Shafer</Author>
			<Title>Providing a Framework for Effective Software Quality Assessment</Title>
			<Publication_Year>1996</Publication_Year>
			<Publication_Month>--07</Publication_Month>
			<URL>https://www.researchgate.net/publication/285403022_PROVIDING_A_FRAMEWORK_FOR_EFFECTIVE_SOFTWARE_QUALITY_MEASUREMENT_MAKING_A_SCIENCE_OF_RISK_ASSESSMENT</URL>
		</External_Reference>
   </External_References>
</Weakness_Catalog>